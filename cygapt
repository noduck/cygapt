#!/usr/bin/perl

use strict;
use warnings;
use feature qw(:5.20);
use Getopt::Long;
use LWP;
use Compress::Bzip2;
use URI::Escape qw(uri_escape);
use Text::Glob qw(glob_to_regex);
use POSIX qw(uname);
use Time::HiRes qw(time sleep);
use Data::Dumper;

# TODO: link last-cache to /var/cache/cygapt??

use constant {
	SETUP => "/etc/setup/setup.rc",
	INSTALLED => "/etc/setup/installed.db",
	# not using the cache from setup.ini
	CACHE => "/var/cache/cygapt",
	VERSION => "0.2",
};
my (%setup, %package);

my ($installed, $upgradable, $allversions, $downgrades, $yes,
	$downloadonly, $purge, $dryrun, $verbose);
our ($target_release, $target_version);
my $debug = 0;
my $root = '';
GetOptions(
	"i|installed"	=> \$installed,
	"u|upgradable|upgradeable" => \$upgradable,
	"a|all-versions" => \$allversions,
	"t|target=s"	=> \$target_release,
	"downgrades|allow-downgrades" => \$downgrades,
	"y|yes"		=> \$yes,
	"d|download-only" => \$downloadonly,
	"purge"		=> \$purge,
	"s|simulate|n|dry-run" => \$dryrun,
	"v|verbose"	=> \$verbose,
	"D|debug:+"	=> \$debug,
	"h|help"	=> sub { usage() },
	"root=s"	=> \$root,
) or usage("");

if (! $root) {
} elsif (! -d $root) {
	print STDERR "E: root directory $root is not accessible: $!\n";
	exit 10;
} elsif ($root =~ s{/+$}{}) {
}

$target_release = glob2re($target_release)
	if $target_release;

usage()
	unless @ARGV;
my $cmd = shift @ARGV;

if ($cmd eq 'vcmp' && @ARGV == 2) {
	my $a = v2va($ARGV[0]);
	my $b = v2va($ARGV[1]);
	my $cmp = vacmp($a, $b);
	print "$ARGV[0] ", ($cmp > 0 ? ">" : $cmp < 0 ? "<" : "=="),
		" $ARGV[1]\n";
	exit 0;
} elsif ($cmd !~ /^(?:list|show|install|remove|
	update|upgrade|clean|autoremove)$/x) {
	print STDERR "E: Invalid command $cmd\n";
	exit 10;
}

get_setup();

if ($cmd eq 'list') {
	$| = 1;
	print "Listing... ";
	get_installed();
	get_available();
	print "Done\n";
	list({ upgradable => $upgradable, installed => $installed },
		@ARGV);
} elsif ($cmd eq 'show') {
	unless (@ARGV) {
		print STDERR "E: No packages found\n";
		exit 10;
	}
	get_installed();
	get_available();
	list({ show => 1, upgradable => $upgradable, installed => $installed },
		@ARGV);
} elsif ($cmd eq 'update') {
	if (@ARGV) {
		print STDERR "E: The update command takes no arguments\n";
		exit 10;
	}
	update();
} elsif (1) {
	print STDERR "E: Not implemented yet\n";
	exit 10;
} elsif ($cmd eq 'install') {
} elsif ($cmd eq 'remove') {
} elsif ($cmd eq 'upgrade') {
} elsif ($cmd eq 'clean') {
	if (@ARGV) {
		print STDERR "E: The clean command takes no arguments\n";
		exit 10;
	}
	clean();
} elsif ($cmd eq 'autoremove') {
	if (@ARGV) {
		print STDERR "E: The autoremove command takes no arguments\n";
		exit 10;
	}
	autoremove();
}

sub list {
	my $opt = { };
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';
	my $idx;

	my (@re, @t_rel, @t_ver);
	for (@_) {
		print STDERR "W: only select target version or release: $_\n"
			if m{/} && m{=};

 		push @t_rel, s{/(\S+)}{} ? glob2re($1) : $target_release;
		push @t_ver, s{=(\S+)}{} ? glob2re($1) : $target_version;

		push @re, glob2re($_)."(?{ \$idx = ".scalar(@re)." })";
	}

	my $re;
	if (@re) {
		use re 'eval';
		$re = join('|', @re);
		$re = qr/(?:$re)/;
		print STDERR "Match: $re\n"
			if $debug;
	}

	my $count = 0;
	for my $pack (sort keys %package) {
		next
			if $re && $pack !~ $re;
		my $p = $package{$pack};
		local ($target_release, $target_version)
			= ($target_release, $target_version);
		if (defined $idx) {
			$target_release = $t_rel[$idx];
			$target_version = $t_ver[$idx];
		}

		next
			if ($opt->{installed} || $opt->{upgradable})
			&& ! $p->{v_installed};

		select_package_versions($p);

		# upgradable needs to be installed, and not the upgrade
		# version
		next
			if $opt->{upgradable}
			&& (! $p->{v_installed}
				|| ! $p->{v_target}
				|| $p->{v_installed} eq $p->{v_target});

		print Dumper($p)
			if $debug > 1;

		my $u_t;
		$u_t =  $p->{versions}{$p->{v_target}}{version_idx}
			< $p->{versions}{$p->{v_installed}}{version_idx}
			? 'upgradable' : 'downgradable'
			if $p->{v_target} && $p->{v_installed};

		$count++;
		next
			if $opt->{count_only};

		for my $v ($allversions
			? @{$p->{versions_sorted}}
			: $p->{versions}{$p->{v_target}}) {
			my @t;
			push @t, 'installed'
				if $v->{installed};

			push @t, "$u_t from: $p->{v_installed}"
				if $p->{v_installed} && ! $v->{installed}
				&& $p->{v_target}
				&& $v->{version} eq $p->{v_target};
			push @t, "$u_t to: $p->{v_target}"
				if $v->{installed}
				&& $p->{v_target}
				&& $v->{version} ne $p->{v_target};

# TODO: also do show
			if ($opt->{show}) {
print "Show\n";
			}
			print "$pack/", join(",", @{$v->{releases}}), " ",
				$v->{version},
				@t ? " [".join(",", @t)."]" : "",
				"\n";
		}

		print "\n"
			if $allversions;
	}

	return $count;
}

sub update {
	local $| = 1;
	my $ua = get_user_agent();

# TODO: create temporary setup file, start decompressions
	my $url = $setup{last_mirror}[0].'/'.$setup{arch}.'/setup.bz2';
	print "get $url\n"
		if $debug;
	my $req = HTTP::Request->new(GET => $url);

	my $setup_dir = $root.join("/", $setup{cache_mirror}, $setup{arch});
	mkdir_p($setup_dir);
	my $fh;
	unless (open $fh, '>', "$setup_dir/setup.new") {
		print STDERR "E: Could not write $setup_dir/setup.new: $!\n";
		exit 10;
	}
	my ($bz, $bzstat) = bzinflateInit;

	my $data;
	my $size = 0;
	my $total_size;
	my $start = time;
	my $res = $ua->request($req, sub {
		($data, $bzstat) = $bz->bzinflate($_[0]);
		print $fh $data;

		state $last = 0;
		my $res = $_[1];
		$total_size = $res->header('Content-Length') // -1
			unless defined $total_size;
		$size += length($_[0]);

		my $now = time;
		return
			unless $now - $last > 0.1;
		$last = $now;

		my $s;
		unless ($size || $total_size) {
			$s = 'Waiting for headers';
		} elsif ($total_size > 0) {
			$s = sprintf("1 setup.bz2 %s/%s %d%%",
				size2t($size), size2t($total_size),
				100 * $size / $total_size);
		} else {
			$s = "1 setup.bz2 ".size2t($size);
		}
		print "[$s]\r";
	});

	($data, $bzstat) = $bz->bzflush;
	print $fh $data // '';
	($data, $bzstat) = $bz->bzclose;
	print $fh $data // '';
	close($fh);
	my $end = time;

	if ($res->is_success) {
		rename("$setup_dir/setup.new", "$setup_dir/setup.ini");
		print "Get:1 $setup{last_mirror}[0]\n";
		printf "Fetched %s in %ds (%s/s)\n",
			size2t($total_size), $end - $start,
			size2t($total_size / ($end - $start));

	} else {
# TODO: what now?
		print $res->status_line, "\n";
		unlink("$setup_dir/setup.new");
	}

	print "Reading state information... ";
	get_installed();
	get_available();
	my $u = list({ count_only => 1, upgradable => 1});
	print "Done\n";
	print "$u packages can be upgraded. ",
		"Run 'cygapt list --upgradable' to see them.\n"
		if $u;
}

sub get_setup {
	my $fh;

	unless (open $fh, '<', $root.SETUP) {
		print STDERR "E: Cannot open ", $root.SETUP, ": $!\n";
		exit 10;
	}

	my $key;
	while(<$fh>) {
		if ($key && /^\s+(\S.*)\r?\n/) {
			push @{$setup{$key}}, $1;
		} elsif (/^(\S+)\s*$/) {
			($key = $1) =~ s/-/_/g;
		} else {
			print STDERR "W: Did not recognize ", $root.SETUP,
				" format", $key ? " section $key" : "",
				": $_";
		}

	}

	close ($fh);

	unless (exists $setup{last_mirror}) {
		print STDERR "E: Did not find last-mirror in ", SETUP, "\n";
		exit 10;
	}

	$setup{cache_mirror} = CACHE."/".uri_escape($setup{last_mirror}[0]);
	($setup{arch} = (uname)[4]) =~ s/^i6/x/;
}

sub get_user_agent {
	my $ua = LWP::UserAgent->new(
		agent => "cygapt/".VERSION
	);
	$ua->env_proxy;
	$ua->proxy(['http', 'https', 'ftp']
		=> "http://".$setup{net_proxy_host}[0]
			.":".$setup{net_proxy_port}[0])
		if exists $setup{net_proxy_host}
		&& exists $setup{net_proxy_port};
	return $ua;
}

sub get_installed {
	my $fh;

	unless (open $fh, '<', $root.INSTALLED) {
		print STDERR "E: Cannot open ", $root.INSTALLED, ": $!\n";
		exit 10;
	}

	my $version;
	while(<$fh>) {
		if (/^INSTALLED.DB\s+(\d+)/) {
			$version = $1;
			next;
		}

		unless (/^(\S+)\s+\1-(\S+)\.tar\.\S+\s+(\d+)$/) {
			print STDERR "W: Did not recognize ", $root.INSTALLED,
				" format: $_";
			next;
		}
		my ($pack, $version, $picked) = ($1, $2, $3);

		my $p;
		if (exists $package{$pack}) {
			$p = $package{$pack};
		} else {
			$p = $package{$pack} = {
				name => $pack,
				versions => { },
			};
		}
		$p->{v_installed} = $version;
		$p->{picked} = $picked;

		my $v;
		if (exists $p->{versions}{$version}) {
			$v = $p->{versions}{$version};
		} else {
			$v = $p->{versions}{$version} = {
				version => $version,
				va => v2va($version),
			};
		}

		$v->{installed} = 1;
		$v->{version} = $version;
		push @{$v->{releases}}, 'now';
	}

	close($fh);
}

sub get_available {
	my $fh;
	my $setup_name = $root.join("/", $setup{cache_mirror},
		$setup{arch}, "setup.ini");

	unless (open $fh, '<', $setup_name) {
		print STDERR "E: Cannot open ", $setup_name, ": $!\n";
		exit 10;
	}

	my ($key, $val);
	while(<$fh>) {
		next
			if /^\s*#/;

		last
			if /^\s*$/;

	}

	my ($pack, $rel, $vals);
	while(<$fh>) {
		chomp;

		if (/^\@\s+(\S+)/) {
			$pack = $1;
			$rel = 'current';
			#print "package $pack\n";
			next;
		} elsif (/^\[(\S+)\]/) {
			# store
			_available_store($pack, $rel, $vals);
			$rel = $1;
			$vals = undef;
			next;
		} elsif ($key && defined $val) {
			$val .= "\n$_";
		} elsif (/^\s*$/) {
			# store
			_available_store($pack, $rel, $vals);
			$pack = undef;
			$vals = undef;
			next;
		} elsif (/^(\S+):\s+(.*)$/) {
			($key, $val) = ($1, $2);
		} else {
			print STDERR "W: Did not recognize $setup_name",
				" line $. format: $_\n";
			next;
		}

		#print "Val '$val'\n";
		my $q = () = $val =~ /"/g;
		next
			if $q & 1;

		#print "store key $key\n";
		$vals->{$key} = $val;
		$key = undef;
	}

	close($fh);
}

sub _available_store {
	my ($pack, $rel, $vals) = @_;

	unless (exists $vals->{version}) { # && exists $vals->{sdesc}) {
		print STDERR "W: package $pack doesn't have ",
			"'version' tag\n";
		return;
	}
	my $version = $vals->{version};

	my $p;
	if (exists $package{$pack}) {
		$p = $package{$pack};
	} else {
		$p = $package{$pack} = {
			name => $pack,
			versions => { },
		};
	}
	
	for my $k (qw(sdesc ldesc category message)) {
		next
			unless exists $vals->{$k};
		my $t = $vals->{$k};
		$t =~ s/^"(.*)"$/$1/ms;
		$p->{$k} = $t;
		delete $vals->{$k};
	}

	my $v;
	if (exists $p->{versions}{$version}) {
		$v = $p->{versions}{$version};
	} else {
		$v = $p->{versions}{$version} = {
			version => $version,
			va => v2va($version),
		};
	}

	push @{$v->{releases}}, $rel;
	for my $k (keys %$vals) {
		$v->{$k} = $vals->{$k};
	}
}

sub select_package_versions {
	my ($p) = @_;

	print "find $p->{name} for rel ", $target_release // '<u>', 
		" ver ", $target_version // '<u>', "\n"
		if $debug;

	my @v = sort { vacmp($b->{va}, $a->{va}) } values %{$p->{versions}};
	$p->{versions_sorted} = \@v;
	for my $i (0..$#v) {
		$v[$i]{version_idx} = $i;
	}

	$p->{v_latest} = $v[0]{version};

	my $target = $v[-1]{version};
	my $i = 0;
	while($i < @v && $v[$i]{releases}[0] eq 'test') {
		$i++;
	}
	$target = $v[$i]{version}
		unless $i > $#v && $v[$i]{releases}[0] eq 'test';
	$p->{v_target} = $target;

	$target = undef;
	if ($target_version) {
		# newest version that matches $target_version
		$target = (grep m{$target_version}, map($_->{version}, @v))[0];
	} elsif ($target_release) {
		# newest version that has a release that matches $target_release
		$target = (map $_->{version},
			grep {
				grep $_ =~ m{$target_release}, @{$_->{releases}}
			} @v)[0];
	}
	# only pick new target if it is newer, or we can downgrade (or no
	# prior target)
	$p->{v_target} = $target
		if $target && ($downgrades
			|| ! $p->{v_target}
			|| $p->{versions}{$target}{version_idx} <
				$p->{versions}{$p->{v_target}}{version_idx});
}

sub v2va {
	# split into groups of non-digits and digits
	# first is a group of digits
	return [ defined $_[0] ? split(/(\d+)/, $_[0]) : ('') ]
}

sub vacmp {
	my ($a, $b) = @_;
	my $i = 0;

	while(1) {
		last
			unless $i < @$a && $i < @$b;
		my $cmp = $a->[$i] cmp $b->[$i];
		return $cmp
			if $cmp;
		$i++;

		last
			unless $i < @$a && $i < @$b;
		$cmp = $a->[$i] <=> $b->[$i];
		return $cmp
			if $cmp;
		$i++;
	}

	if (@$a == @$b) {
		return 0;
	} elsif ($i < @$a) {
		return +1;
	} else {
		return -1;
	}
}

sub glob2re {
	my ($re) = @_;
	$re = glob_to_regex($re);
	return qr{$re};
}

sub mkdir_p {
	my ($dir) = @_;
	return
		if -d $dir;
	(my $up = $dir) =~ s{/[^/]*$}{};
	mkdir_p($up);
	mkdir $dir;
}

sub size2t {
	my ($s) = @_;
	state $fmt = [
		[ "%d B", 1, ],
		[ "%.1f kB", 1024, ],
		[ "%d kB", 1024, ],
		[ "%.1f MB", 1024 * 1024, ],
		[ "%d MB", 1024 * 1024, ],
	];

	for my $i (0..$#$fmt) {
		my $t = sprintf($fmt->[$i][0], $s / $fmt->[$i][1]);
		return $t
			unless length($t) > 7;
	}
	return sprintf($fmt->[-1][0], $s / $fmt->[-1][1]);
}

sub usage {
	print STDERR @_, "\n"
		if @_;
	print STDERR <<USAGE;
Usage: cygapt [options] command

cygapt is a commandline package manager for Cygwin, that tries to provide
a similar interface as APT on Debian.

Commands:
  list - list packages based on package names
  install - install packages
  remove - remove packages
  update - update list of available packages
  upgrade - upgrade the system by installing/upgrading packages

Options:
  -y, --yes
  -v, --verbose
  -h, --help
USAGE

	exit @_ ? 10 : 0;
}

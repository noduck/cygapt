#!/usr/bin/perl

use strict;
use warnings;
use feature qw(:5.20);
use Getopt::Long qw(:config bundling no_ignore_case);
use Fcntl qw(:flock SEEK_SET);
use LWP;
use Compress::Zlib;
use Compress::Bzip2;
use Text::Glob qw(glob_to_regex);
use POSIX qw(uname);
use Time::HiRes qw(time sleep);
use Term::ReadKey;
use Data::Dumper;

# TODO: link last-cache to /var/cache/cygapt??

use constant {
	SETUP => "/etc/setup/setup.rc",
	INSTALLED => "/etc/setup/installed.db",
	# not using the cache from setup.ini
	CACHE => "/var/cache/cygapt",
	VERSION => "0.2",
};
my (%setup, %package);
# fields in order (not showing install and source)
my @field = (qw(sdesc ldesc category requires version depends2));

my ($installed, $upgradable, $allversions, $target_release, $downgrades, $yes,
	$downloadonly, $purge, $dryrun, $recurse, $fullrecurse, $verbose);
my $debug = 0;
my $root = '';
GetOptions(
	"i|installed"	=> \$installed,
	"u|upgradable|upgradeable" => \$upgradable,
	"a|all-versions" => \$allversions,
	"t|target=s"	=> \$target_release,
	"downgrades|allow-downgrades" => \$downgrades,
	"y|yes"		=> \$yes,
	"d|download-only" => \$downloadonly,
	"purge"		=> \$purge,
	"s|simulate|n|dry-run" => \$dryrun,
	"r|recurse"	=> \$recurse,
	"full-recurse"	=> \$fullrecurse,
	"v|verbose"	=> \$verbose,
	"D|debug:+"	=> \$debug,
	"h|help"	=> sub { usage() },
	"root=s"	=> \$root,
) or usage("");

if (! $root) {
} elsif (! -d $root) {
	print STDERR "E: root directory $root is not accessible: $!\n";
	exit 10;
} elsif ($root =~ s{/+$}{}) {
}

$target_release = glob2re($target_release)
	if $target_release;

usage()
	unless @ARGV;
my $cmd = shift @ARGV;

if ($cmd eq 'vcmp' && @ARGV == 2) {
	my $a = v2va($ARGV[0]);
	my $b = v2va($ARGV[1]);
	my $cmp = vacmp($a, $b);
	print "$ARGV[0] ", ($cmp > 0 ? ">" : $cmp < 0 ? "<" : "=="),
		" $ARGV[1]\n";
	exit 0;
} elsif ($cmd !~ /^(?:list|show|install|remove|
	update|upgrade|clean|autoremove|depends|rdepends)$/x) {
	print STDERR "E: Invalid command $cmd\n";
	exit 10;
}

get_setup();

if ($cmd eq 'list') {
	$| = 1;
	print "Listing... ";
	get_available();
	get_installed();
	print "Done\n";
	list({ upgradable => $upgradable, installed => $installed,
		all => $allversions },
		@ARGV);
	exit 0;
} elsif ($cmd eq 'show') {
	unless (@ARGV) {
		print STDERR "E: No packages found\n";
		exit 10;
	}
	get_installed();
	get_available();
	list({ show => 1, upgradable => $upgradable, installed => $installed,
		all => $allversions},
		@ARGV);
	exit 0;
} elsif ($cmd eq 'update') {
	if (@ARGV) {
		print STDERR "E: The update command takes no arguments\n";
		exit 10;
	}
	update();
	exit 0;
} elsif ($cmd eq 'install') {
	$| = 1;
	print "Reading package lists... ";
	get_available();
	print "Done\n";
	print "Building dependency tree\n";
	build_tree();
	print "Reading state information... ";
	get_installed();
	print "Done\n";

	my $opt = { print => 0 };
	exit 10
		unless list_depends($opt, @ARGV);

	my $uls = $opt->{uninstalled_level};
	my @i = grep ! $uls->{$_}, keys %$uls;
	my @d = sort { $uls->{$b} <=> $uls->{$a} }
		grep $uls->{$_}, keys %$uls;

	make_changes({
		installs => \@i,
		install_deps => \@d,
	});
} elsif ($cmd eq 'remove') {
	$| = 1;
	print "Reading package lists... ";
	get_available();
	print "Done\n";
	print "Building dependency tree\n";
	build_tree();
	print "Reading state information... ";
	get_installed();
	print "Done\n";

	my $opt = { print => 0 };
	exit 10
		unless list_rdepends($opt, @ARGV);
	my $u = $opt->{installed_level};
	make_changes({
		removes => [ sort { $u->{$b} <=> $u->{$a} } keys %$u ],
	});
} elsif ($cmd eq 'upgrade') {
	$| = 1;
	print "Reading package lists... ";
	get_available();
	print "Done\n";
	print "Building dependency tree\n";
	build_tree();
	print "Reading state information... ";
	get_installed();
	print "Done\n";

	my ($upgrades, $new_deps) = upgradable(@ARGV);
	print "Calculating upgrade... Done\n";

	make_changes({
		upgrade_deps => $new_deps,
		upgrades => $upgrades,
	});
} elsif ($cmd eq 'clean') {
	if (@ARGV) {
		print STDERR "E: The clean command takes no arguments\n";
		exit 10;
	}
	clean();
	exit 0;
} elsif ($cmd eq 'autoremove') {
	if (@ARGV) {
		print STDERR "E: The autoremove command takes no arguments\n";
		exit 10;
	}
	print STDERR "E: Not implemented yet\n";
	exit 10;
	autoremove();
	exit 0;
} elsif ($cmd eq 'depends') {
	unless (@ARGV) {
		print STDERR "E: No packages found\n";
		exit 10;
	}
	$| = 1;
	print "Reading package lists... ";
	get_available();
	print "Done\n";
	print "Building dependency tree\n";
	build_tree();
	print "Reading state information... ";
	get_installed();
	print "Done\n";

	list_depends({
			recurse => $recurse ? ~0 : 1,
			fullrecurse => $fullrecurse ? ~0 : 1,
		},@ARGV);
} elsif ($cmd eq 'rdepends') {
	unless (@ARGV) {
		print STDERR "E: No packages found\n";
		exit 10;
	}
	$| = 1;
	print "Reading package lists... ";
	get_available();
	print "Done\n";
	print "Building dependency tree\n";
	build_tree();
	print "Reading state information... ";
	get_installed();
	print "Done\n";

	list_rdepends(@ARGV);
}
exit 0;

sub list {
	my $opt = { };
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';

	my ($re, $t_rels, $t_vers) = argv2re(@_);

	my $count = 0;
	for my $pack (sort keys %package) {
		$a = undef;
		next
			if $re && $pack !~ $re;
		my $p = $package{$pack};
		next
			if ($opt->{installed} || $opt->{upgradable})
			&& ! $p->{v_installed};

		select_package_versions($p,
			defined $a ? $t_rels->[$a] : $target_release,
			defined $a ? $t_vers->[$a] : undef);

		# upgradable needs to be installed, and not the upgrade
		# version
		next
			if $opt->{upgradable}
			&& (! $p->{v_installed}
				|| ! $p->{v_target}
				|| $p->{v_installed} eq $p->{v_target});

		print Dumper($p)
			if $debug > 1;

		$count++;
		next
			if $opt->{count_only};

		my $u_t;
		if ($opt->{show}) {
			print "@ $pack\n";
			for my $f (@field) {
				next
					unless exists $p->{"tag_$f"};
				print "$f: ", $p->{"tag_$f"}, "\n";
			}
		} elsif ($p->{v_target} && $p->{v_installed}) {
			# upgrade or downgrade?
			$u_t =  $p->{versions}{$p->{v_target}}{version_idx}
				< $p->{versions}{$p->{v_installed}}{version_idx}
				? 'upgradable' : 'downgradable'
		}

		my $first = 1;
		for my $v ($opt->{all}
			? @{$p->{versions_sorted}}
			: $p->{versions}{$p->{v_target}}) {
			if ($opt->{show}) {
				print "[", join(",", @{$v->{releases}}), "]\n"
					unless $first;

				for my $f (@field) {
					next
						unless exists $v->{"tag_$f"};
					print "$f: ", $v->{"tag_$f"}, "\n";
				}

				print "status: ",
					$p->{picked} ? "manually installed"
						: "system installed",
					"\n"
					if $opt->{all} && $v->{installed}
					|| ! $opt->{all} && $p->{v_installed};

				$first = undef;
				next;
			}

			my @t;
			push @t, 'installed'
				if $v->{installed} && ! $opt->{show};

			push @t, "$u_t from: $p->{v_installed}"
				if $p->{v_installed} && ! $v->{installed}
				&& $p->{v_target}
				&& $v->{tag_version} eq $p->{v_target};
			push @t, "$u_t to: $p->{v_target}"
				if $v->{installed}
				&& $p->{v_target}
				&& $v->{tag_version} ne $p->{v_target};

			print "$pack/", join(",", @{$v->{releases}}),
				" ", $v->{tag_version},
				@t ? " [".join(",", @t)."]" : "",
				"\n";
		}

		print "\n"
			if $opt->{all} || $opt->{show};
	}

	return $count;
}

sub update {
	local $| = 1;

	my $url = $setup{last_mirror}[0].'/'.$setup{arch}.'/setup.bz2';

	my $file = $root.join("/", $setup{cache_mirror}, $setup{arch},
		"setup.ini");

	my ($bz, $bzstat) = bzinflateInit;
	my $res = http_get($url, $file, undef, sub {
		if (defined $_[0]) {
			my ($data, $bzstat) = $bz->bzinflate($_[0]);
			return $data;
		} else {
			my ($data, $bzstat) = $bz->bzflush;
			my $t = $data // '';
			($data, $bzstat) = $bz->bzclose;
			return $t.($data // '');
		}
	});

	unless ($res) {
		exit 10;
	}
	http_done();

	print "Reading state information... ";
	get_installed();
	get_available();
	my $u = list({ count_only => 1, upgradable => 1});
	print "Done\n";
	print "$u packages can be upgraded. ",
		"Run 'cygapt list --upgradable' to see them.\n"
		if $u;
}

sub make_changes {
	my ($changes) = @_;
	$changes->{installs} //= [];
	$changes->{install_deps} //= [];
	$changes->{upgrades} //= [];
	$changes->{upgrade_deps} //= [];
	$changes->{removes} //= [];
	$changes->{remove_rdeps} //= [];

	my $nc = @{$changes->{installs}}
		+ @{$changes->{install_deps}}
		+ @{$changes->{upgrade_deps}};
	my $uc = @{$changes->{upgrades}};
	my $rc = @{$changes->{removes}}
		+ @{$changes->{remove_rdeps}};
	my $nuc = list({ count_only => 1, upgradable => 1}) - $uc;
	my $ask;

	lock_installed();

	# deps for install
	if (@{$changes->{install_deps}}) {
		print "The following additional packages will be installed:\n";
		print_array(sort @{$changes->{install_deps}});
		$ask = 1;
	}
	# anything new to install (explicitly install, deps for install/upgrade)
	if ($nc) {
		print "The following NEW packages will be installed:\n";
		print_array(sort(@{$changes->{installs}},
			@{$changes->{install_deps}},
			@{$changes->{upgrade_deps}}));
	}
	# upgrades
	if ($uc) {
		print "The following packages will be upgraded:\n";
		print_array(sort @{$changes->{upgrades}});
		$ask = 1;
	}
	# removes (explicit remove, and rdepends)
	if ($rc) {
		print "The following packages will be REMOVED:\n";
		print_array(sort(@{$changes->{removes}},
			@{$changes->{remove_rdeps}}));
		$ask = 1;
	}

	print "$uc upgraded, $nc newly installed, $rc to remove and ",
		"$nuc not upgraded.\n";
	return
		unless $uc || $nc || $rc;

	my @get;
	my %file;
	my ($get_size, $total_size) = (0, 0);
	for my $pack (sort @{$changes->{installs}},
			@{$changes->{install_deps}},
			@{$changes->{upgrade_deps}},
			@{$changes->{upgrades}}) {
		my $p = $package{$pack};
		unless ($p->{v_target}) {
			print STDERR "E: no target version was ",
				"selected for $pack\n";
			exit 10;
		}

		my $v = $p->{versions}{$p->{v_target}};
		my @install = split /\s+/, $v->{tag_install};
		my $file = $root.join("/", $setup{cache_mirror}, $install[0]);
		$file{$pack} = $file;
		$total_size += $install[1];
		next
			if -f $file;

		push @get, {
			url => $v->{base}.$install[0],
			file => $file,
			size => $install[1],
			hash => $install[2],
		};
		$get_size += $install[1];
	}
	print "Need to get ",
		$total_size == $get_size ?  size2t($get_size)
		: size2t($get_size)."/".size2t($total_size),
		" of archives.\n";
	# Cygwin does not provide information about installed size
	# print "After this operation, ", ...
	#	? "232 kB of additional disk space will be used.\n"
	#	: "13.1 MB disk space will be freed.\n";

	if ($ask && ! $yes) {
		local $| = 1;
		print "Do you want to continue? [Y/n] ";
		$_ = <STDIN>;
		return
			unless $_ =~ /^\s*(?:y.*)?\s*$/;
	}

	if (@get) {
		my $c;
		for my $g (@get) {
			$c++
				if http_get($g->{url}, $g->{file}, $g->{size});
		}
		if ($c == @get) {
			http_done();
		} else {
			print STDERR "E: could not download all packages.\n";
			exit 10;
		}
	}

	if ($downloadonly) {
		print "Download complete and in download only mode\n";
		return;
	}

	for my $pack (@{$changes->{install_deps}},
			@{$changes->{upgrade_deps}}) {
		do_install($pack, $package{$pack}{v_target}, $file{$pack}, 0);
	}
	for my $pack (@{$changes->{installs}}) {
		do_install($pack, $package{$pack}{v_target}, $file{$pack}, 1);
	}
	for my $pack (@{$changes->{upgrades}}) {
		do_upgrade($pack, $package{$pack}{v_installed},
			$package{$pack}{v_target}, $file{$pack});
	}
	for my $pack (@{$changes->{remove_rdeps}},
			@{$changes->{removes}}) {
		do_remove($pack);
	}

	unlock_installed();
}

sub do_install {
	my ($pack, $vers, $tar, $picked) = @_;

	(my $fname = $tar) =~ s{^.*/}{};
	print "Preparing to unpack .../$fname ...\n";

	if ($dryrun) {
		print "\tdryrun\n";
		return;
	}

	my $lst_fh;
	my $lst_name = "$root/etc/setup/$pack.lst.gz";
	unless ($lst_fh = gzopen($lst_name, 'wb')) {
		print STDERR "E: Cannot write $lst_name: $!\n";
		exit 10;
	}

	print "Unpacking $pack ($vers) ...\n";
	my $tar_fh;
	unless (open $tar_fh, '-|',
		'tar', '-C', "$root/",
		$tar =~ m{\.gz} ? '-z'
			: $tar =~ m{\.bz2} ? '-j'
			: $tar =~ m{\.bz2} ? '-J'
			: (),
		'-vxf', $tar) {
		print STDERR "E: Cannot start tar $tar: $!\n";
		exit 10;
	}

	while(<$tar_fh>) {
		$lst_fh->gzwrite($_);
		print $_
			if $debug;
	}

	close($tar_fh);
	$lst_fh->gzclose;

	print "Setting up $pack ($vers) ...\n";
	for my $post (glob("$root/etc/postinstall/*.sh")) {
		print "running $post\n"
			if $debug;
		$post =~ s{^$root}{};
		my $rc = system($root ? ('chroot', "$root/") : (), $post);
		rename($root.$post, "$root$post.done")
			unless $rc;
	}

	my $p = $package{$pack};
	$p->{v_installed} = $vers;
	$p->{versions}{$p->{v_installed}}{installed} = 1;
	$p->{picked} = $picked;
	write_installed();
}

sub do_upgrade {
	my ($pack, $old_vers, $new_vers, $tar) = @_;

	(my $fname = $tar) =~ s{^.*/}{};
	print "Preparing to unpack .../$fname ...\n";

	if ($dryrun) {
		print "\tdryrun\n";
		return;
	}

	my %old_file;
	my $lst_fh;
	my $lst_name = "$root/etc/setup/$pack.lst.gz";
	if ($lst_fh = gzopen($lst_name, 'rb')) {
		my $line;
		while($lst_fh->gzreadline($line)) {
			chomp($line);
			$old_file{$line}++;
		}
		$lst_fh->gzclose;
	}

	unless ($lst_fh = gzopen($lst_name, 'wb')) {
		print STDERR "E: Cannot write $lst_name: $!\n";
		exit 10;
	}

	print "Unpacking $pack ($new_vers) over ($old_vers) ...\n";
	my $tar_fh;
	unless (open $tar_fh, '-|',
		'tar', '-C', "$root/",
		$tar =~ m{\.gz} ? '-z'
			: $tar =~ m{\.bz2} ? '-j'
			: $tar =~ m{\.bz2} ? '-J'
			: (),
		'-vxf', $tar) {
		print STDERR "E: Cannot start tar $tar: $!\n";
		exit 10;
	}

	while(<$tar_fh>) {
		$lst_fh->gzwrite($_);
		print $_
			if $debug;
		chomp;
		delete $old_file{$_};
	}

	close($tar_fh);
	$lst_fh->gzclose;

	for my $file (sort { $b cmp $a } keys %old_file) {
# TODO: how to test this?
		if ($file =~ m{^etc/postinstall/.*\.sh$}) {
			unlink "$root/$file";
			unlink "$root/$file.done";
		} elsif ($file =~ m{/$}) {
			rmdir "$root/$file";
		} else {
			unlink "$root/$file";
		}
	}

	print "Setting up $pack ($new_vers) ...\n";
	for my $post (glob("$root/etc/postinstall/*.sh")) {
		print "running $post\n"
			if $debug;
		$post =~ s{^$root}{};
		my $rc = system($root ? ('chroot', "$root/") : (), $post);
		rename($root.$post, "$root$post.done")
			unless $rc;
	}

	my $p = $package{$pack};
	$p->{v_installed} = $new_vers;
	delete $p->{versions}{$old_vers}{installed};
	$p->{versions}{$new_vers}{installed} = 1;
	write_installed();
}

sub do_remove {
	my ($pack) = @_;
	my $p = $package{$pack};

	print "Removing $pack ($p->{v_installed}) ...\n";

	if ($dryrun) {
		print "\tdryrun\n";
		return;
	}

	my $pre = "/etc/preremove/$pack.sh";
	if (-f $root.$pre) {
		print "running $pre\n"
			if $debug;
		system($root ? ('chroot', "$root/") : (), $pre);
	}

	my $lst_fh;
	my $lst_name = "$root/etc/setup/$pack.lst.gz";
	if ($lst_fh = gzopen($lst_name, 'rb')) {
		my $line;
		while($lst_fh->gzreadline($line)) {
			chomp($line);
			if ($line =~ m{^etc/postinstall/.*\.sh$}) {
				unlink "$root/$line";
				unlink "$root/$line.done";
			} elsif ($line =~ m{/$}) {
				rmdir "$root/$line";
			} else {
				unlink "$root/$line";
			}
		}
		$lst_fh->gzclose;
		unlink($lst_name);
	} else {
		print STDERR "W: Cannot read $lst_name: $!\n";
	}

	delete $p->{versions}{$p->{v_installed}}{installed};
	delete $p->{v_installed};
	delete $p->{picked};
	write_installed();
}

sub clean {
	system('find', $root.CACHE,
		qw(-mindepth 4 -maxdepth 4 -exec rm -r {} ;));
}

sub build_tree {
	for my $p (values %package) {
		_build_tree($p, 0);
	}
}

sub _build_tree {
	my ($p, $n) = @_;

	return
		if exists $p->{dep_depth};
	# loop detection
	print "_build_tree $p->{name} [$n]\n"
		if $debug > 2;
	if ($p->{loop}) {
		print "looping on $p->{name}; depth 0\n"
			if $debug > 2;
		$p->{dep_depth} = 0;
		return;
	}
	$p->{loop} = 1;

	my $max_dep_depth = 0;
	for my $v (values %{$p->{versions}}) {
		my @dep;
		if (exists $v->{tag_depends2}) {
			@dep = split /,\s*/, $v->{tag_depends2};
		} elsif (exists $p->{tag_requires}) {
			@dep = split /\s+/, $p->{tag_requires};
		}
		$v->{deps} = \@dep;

		print "\t$p->{name} $v->{version}: @dep\n"
			if $debug > 2;
		if (@dep) {
			for my $d (@dep) {
				unless (exists $package{$d}) {
					print "unsatisfied dep from ",
						"$p->{name} to $d\n"
						if $debug;
					$max_dep_depth = -10_000;
					last;
				}
				my $rd = $package{$d};
				push @{$rd->{rdeps}}, $p->{name};
				_build_tree($rd, $n+1);
				$max_dep_depth = $rd->{dep_depth} + 1
					unless $max_dep_depth
						> $rd->{dep_depth} + 1;
			}
		}
	}

	$p->{dep_depth} = $max_dep_depth;
	delete $p->{loop};
	print "_build_tree $p->{name} [$n]: $max_dep_depth\n"
		if $debug > 2;
}

sub upgradable {
	my @arg_found;
	my ($re, $t_rels, $t_vers) = argv2re(@_);

	my @upgrade;
	for my $pack (keys %package) {
		my $p = $package{$pack};
		next
			unless $p->{v_installed};

		$a = undef;
		if ($re) {
			next
				if $pack !~ $re;
			$arg_found[$a]++;
		}

		select_package_versions($p,
			defined $a ? $t_rels->[$a] : $target_release,
			defined $a ? $t_vers->[$a] : undef);

		if (! $p->{v_target}) {
			print STDERR "W: no installable version for $pack\n"
				if $re;
			next;
		} elsif ($p->{v_target} eq $p->{v_installed}) {
			print "$pack is already the newest ",
				"version ($p->{v_installed})\n"
				if $re;
			next;
		}

		push @upgrade, $pack;
	}

	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		print STDERR "E: Unable to locate package $_[$i]\n";
		$rc = 0;
	}
	return ([], [])
		unless $rc;

# TODO: upgrades of already installed should also follow dependency order!
# otherwise, do lib before others
	my %opt;
	map(depends(\%opt, $_), @upgrade)
		if @upgrade;

	my $u = $opt{uninstalled_level};
	return ([ sort { $package{$b}{dep_depth} <=> $package{$a}{dep_depth} }
			@upgrade ],
		[ sort { $u->{$b} <=> $u->{$a} } keys %$u ]);
}

sub list_depends {
	my $opt = { };
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';
	$opt->{fullrecurse} //= 1;
	$opt->{recurse} //= ~0;
	$opt->{print} //= 1;
	$opt->{uninstalled_level} //= { };

	my @arg_found;
	my ($re, $t_rels, $t_vers) = argv2re(@_);

	for my $pack (sort keys %package) {
		$a = undef;
		next
			if $re && $pack !~ $re;
		$arg_found[$a]++;
		my $p = $package{$pack};

		$opt->{t_rel} = $t_rels->[$a];
		$opt->{t_ver} = $t_vers->[$a];
		select_package_versions($p, $opt->{t_rel}, $opt->{t_ver});

		if (! $p->{v_installed} || ! $p->{v_target}) {
		} elsif ($p->{v_installed} ne $p->{v_target}) {
# TODO: mark $pack for upgrade
print "Should mark $pack for upgrade!\n";
		} else {
			print "$pack is already the newest version ",
				"($p->{v_installed})\n";
		}

		depends($opt, $pack);
	}

	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		print STDERR "E: Unable to locate package $_[$i]\n";
		$rc = 0;
	}
	return $rc;
}

sub depends {
	my ($opt, $pack) = @_;
	# defaults to collecting all uninstalled
	$opt->{level} //= 0;
	$opt->{recurse} //= ~0;
	$opt->{fullrecurse} //= 0;
	$opt->{uninstalled_level} //= { };
	my $rc = 1;

	return $rc
		if $opt->{depends}{$pack};
	unless (exists $package{$pack}) {
		print STDERR "E: no installable version for $pack\n";
		return 0;
	}
	my $p = $package{$pack};
	$opt->{depends}{$pack}++;

	select_package_versions($p, $opt->{t_rel}, $opt->{t_ver});
	print '  ' x $opt->{level}, $pack,
		$p->{v_installed} ? " [installed]" : "", "\n"
		if $opt->{print};
	# recurse until we find an installed version
	# or if fullrecurse
	return $rc
		if ($opt->{recurse} <= 0
			|| $p->{v_installed}
				&& $p->{v_installed} eq $p->{v_target})
		&& $opt->{fullrecurse} <= 0;
	$opt->{uninstalled_level}{$pack} = $opt->{level}
		unless $p->{v_installed}
		|| (exists $opt->{uninstalled_level}{$pack}
			&& $opt->{uninstalled_level}{$pack} > $opt->{level});
	unless ($p->{v_target}) {
		print STDERR "E: no installable version for $pack\n";
		return 0;
	}

	my $v = $p->{versions}{$p->{v_target}};
	my %opt2 = (
		%$opt,
		level => $opt->{level}+1,
		recurse => $opt->{recurse}-1,
		fullrecurse => $opt->{fullrecurse}-1,
		t_ver => undef
	);
	for my $d (@{$v->{deps}}) {
		$rc = 0
			unless depends(\%opt2, $d);
	}

	return $rc;
}

sub list_rdepends {
	my $opt = { };
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';
	$opt->{print} //= 1;
	$opt->{level} //= 0;
	$opt->{installed_level} //= { };

	my @arg_found;
	my ($re) = argv2re(@_);
	for my $pack (sort keys %package) {
		next
			unless $pack =~ m{$re}
			&& ! exists $opt->{rdepends}{$pack}
			&& $package{$pack}{v_installed};
		$arg_found[$a]++;
		my $p = $package{$pack};

		print $pack, "\n"
			if $opt->{print};
		rdepends({ %$opt, level => $opt->{level}+1 }, $pack);
	}

	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		print STDERR "E: Unable to locate installed package $_[$i]\n";
		$rc = 0;
	}
	return $rc;
}

sub rdepends {
	my ($opt, $dep) = @_;
	$opt->{level} //= 0;

	for my $pack (@{$package{$dep}{rdeps}}) {
		next
			if exists $opt->{rdepends}{$pack}
			|| ! $package{$pack}{v_installed};
		my $p = $package{$pack};
		$opt->{rdepends}{$pack} = 1;
		$opt->{installed_level}{$pack} = $p->{dep_depth};

		print '  ' x $opt->{level}, "$pack\n"
			if $opt->{print};
		rdepends({ %$opt, level => $opt->{level}+1 }, $pack);
	}
}

sub get_setup {
	my $fh;

	unless (open $fh, '<', $root.SETUP) {
		print STDERR "E: Cannot open ", $root.SETUP, ": $!\n";
		exit 10;
	}

	my $key;
	while(<$fh>) {
		if ($key && /^\s+(\S.*)\r?\n/) {
			push @{$setup{$key}}, $1;
		} elsif (/^(\S+)\s*$/) {
			($key = $1) =~ s/-/_/g;
		} else {
			print STDERR "W: Did not recognize ", $root.SETUP,
				" format", $key ? " section $key" : "",
				": $_";
		}

	}

	close ($fh);

	unless (exists $setup{last_mirror}) {
		print STDERR "E: Did not find last-mirror in ", SETUP, "\n";
		exit 10;
	}

	$setup{cache_mirror} = CACHE."/".uri_escape($setup{last_mirror}[0]);
	($setup{arch} = (uname)[4]) =~ s/^i6/x/;
}

sub print_array {
	my ($width) = GetTerminalSize();
	$width--;

	print " ";
	my $w = 1;
	for my $a (@_) {
		if ($w + length($a) >= $width) {
			print "\n  $a";
			$w = 2 + length($a);
		} else {
			print " $a";
			$w += 1 + length($a);
		}
	}
	print "\n";
}

sub get_installed {
	my $fh;

	unless (open $fh, '<', $root.INSTALLED) {
		print STDERR "\nE: Cannot open ", $root.INSTALLED, ": $!\n";
		exit 10;
	}
	unless (flock($fh, LOCK_SH | LOCK_NB)) {
		print STDERR "\nE: Could not get lock ", $root.INSTALLED,
			" - open ($!)\n";
		exit 10;
	}

	my $version;
	while(<$fh>) {
		if (/^INSTALLED.DB\s+(\d+)/) {
			$version = $1;
			next;
		}

		unless (/^(\S+)\s+(\1-(\S+)\.tar\.\S+)\s+(\d+)$/) {
			print STDERR "W: Did not recognize ", $root.INSTALLED,
				" format: $_";
			next;
		}
		my ($pack, $file, $version, $picked) = ($1, $2, $3, $4);

		my $p;
		if (exists $package{$pack}) {
			$p = $package{$pack};
		} else {
			$p = $package{$pack} = {
				name => $pack,
				versions => { },
			};
		}
		$p->{v_installed} = $version;
		$p->{picked} = $picked;

		my $v;
		if (exists $p->{versions}{$version}) {
			$v = $p->{versions}{$version};
		} else {
			$v = $p->{versions}{$version} = {
				tag_version => $version,
				va => v2va($version),
			};
		}

		$v->{installed} = 1;
		$v->{tag_version} = $version;
		$v->{file} = $file;
		push @{$v->{releases}}, 'now';
	}

	close($fh);
}

my $installed_fh;
sub lock_installed {
	return
		if $installed_fh;

	rename($root.INSTALLED, $root.INSTALLED.".orig");
	unless (open $installed_fh, '+>', $root.INSTALLED) {
		print STDERR "E: Cannot open ", $root.INSTALLED, ": $!\n";
		exit 10;
	}
	unless (flock($installed_fh, LOCK_EX)) {
		print STDERR "E: Could not get lock ", $root.INSTALLED,
			" - open ($!)\n";
		exit 10;
	}

	write_installed();
}

sub write_installed {
	die "write_installed() called without lock held"
		unless $installed_fh;

	# protect against incomplete installed.db updates
	my $break;
	local $SIG{INT} = sub { $break = 1 };
	$SIG{TERM} = $SIG{INT};
	$SIG{QUIT} = $SIG{INT};

	seek($installed_fh, 0, SEEK_SET);

	print $installed_fh "INSTALLED.DB 3\n";
	for my $pack (sort keys %package) {
		my $p = $package{$pack};
		next
			unless $p->{v_installed};

		my $file;
		if (exists $p->{versions}{$p->{v_installed}}) {
			my $v = $p->{versions}{$p->{v_installed}};
			if (exists $v->{file}) {
				$file = $v->{file};
			} elsif (exists $v->{tag_install}) {
				$file = $v->{tag_install};
				$file =~ s{\s+.*$}{};
				$file =~ s{^.*/}{};
			}
		}
		$file //= "$pack-$p->{v_installed}.tar.bz2";

		print $installed_fh "$pack $file $p->{picked}\n";
	}
	truncate($installed_fh, tell($installed_fh));

	if ($debug > 1) {
		print "INSTALLED DIFF:\n";
		system('diff', '-u', $root.INSTALLED.".orig", $root.INSTALLED);
		print "END INSTALLED DIFF:\n";
	}

	if ($break) {
		print STDERR "E: Killed\n";
		exit 10;
	}
}

sub unlock_installed {
	write_installed();
	flock($installed_fh, LOCK_UN | LOCK_NB);
	close($installed_fh);
	$installed_fh = undef;
}

sub get_available {
	my $fh;
	my $setup_name = $root.join("/", $setup{cache_mirror},
		$setup{arch}, "setup.ini");

	unless (open $fh, '<', $setup_name) {
		print STDERR "E: Cannot open ", $setup_name, ": $!\n";
		exit 10;
	}

	my ($key, $val);
	while(<$fh>) {
		next
			if /^\s*#/;

		last
			if /^\s*$/;

	}

	my ($pack, $rel, $vals);
	while(<$fh>) {
		chomp;

		if (/^\@\s+(\S+)/) {
			$pack = $1;
			$rel = 'current';
			#print "package $pack\n";
			$vals->{base} = $setup{last_mirror}[0];
			next;
		} elsif (/^\[(\S+)\]/) {
			# store
			_available_store($pack, $rel, $vals);
			$rel = $1;
			$vals = undef;
			next;
		} elsif ($key && defined $val) {
			$val .= "\n$_";
		} elsif (/^\s*$/) {
			# store
			_available_store($pack, $rel, $vals);
			$pack = undef;
			$vals = undef;
			next;
		} elsif (/^(\S+):\s+(.*)$/) {
			($key, $val) = ($1, $2);
		} else {
			print STDERR "W: Did not recognize $setup_name",
				" line $. format: $_\n";
			next;
		}

		#print "Val '$val'\n";
		my $q = () = $val =~ /"/g;
		next
			if $q & 1;

		#print "store key $key\n";
		$vals->{"tag_$key"} = $val;
		$key = undef;
	}

	close($fh);
}

sub _available_store {
	my ($pack, $rel, $vals) = @_;

	unless (exists $vals->{tag_version}) { # && exists $vals->{sdesc}) {
		print STDERR "W: package $pack doesn't have ",
			"'version' tag\n";
		return;
	}
	my $version = $vals->{tag_version};

	my $p;
	if (exists $package{$pack}) {
		$p = $package{$pack};
	} else {
		$p = $package{$pack} = {
			name => $pack,
			versions => { },
		};
	}
	
	for my $k (qw(tag_sdesc tag_ldesc tag_category tag_message
		tag_requires)) {
		next
			unless exists $vals->{$k};
		my $t = $vals->{$k};
		$t =~ s/^"(.*)"$/$1/ms;
		$p->{$k} = $t;
		delete $vals->{$k};
	}

	my $v;
	if (exists $p->{versions}{$version}) {
		$v = $p->{versions}{$version};
	} else {
		$v = $p->{versions}{$version} = {
			version => $version,
			va => v2va($version),
		};
	}

	push @{$v->{releases}}, $rel;
	for my $k (keys %$vals) {
		$v->{$k} = $vals->{$k};
	}
}

sub select_package_versions {
	my ($p, $t_rel, $t_ver) = @_;

	return
		if exists $p->{t_rel} && $p->{t_rel} eq ($t_rel // '')
		&& exists $p->{t_ver} && $p->{t_ver} eq ($t_ver // '');
	$p->{t_rel} = $t_rel // '';
	$p->{t_ver} = $t_ver // '';

	print "find $p->{name} for rel ", $t_rel // '<u>', 
		" ver ", $t_ver // '<u>', "\n"
		if $debug;

	my @v = sort { vacmp($b->{va}, $a->{va}) } values %{$p->{versions}};
	$p->{versions_sorted} = \@v;
	for my $i (0..$#v) {
		$v[$i]{version_idx} = $i;
	}

	$p->{v_latest} = $v[0]{tag_version};

	my $target = $v[-1]{tag_version};
	my $i = 0;
	while($i < @v && $v[$i]{releases}[0] eq 'test') {
		$i++;
	}
	$target = $v[$i]{tag_version}
		unless $i > $#v && $v[$i]{releases}[0] eq 'test';
	$p->{v_target} = $target;

	$target = undef;
	if ($t_ver) {
		# newest version that matches $t_ver
		$target = (grep m{$t_ver},
			map($_->{tag_version}, @v))[0];
	} elsif ($t_rel) {
		# newest version that has a release that matches $t_rel
		$target = (map $_->{tag_version},
			grep {
				grep $_ =~ m{$t_rel}, @{$_->{releases}}
			} @v)[0];
	}
	# only pick new target if it is newer, or we can downgrade (or no
	# prior target)
	$p->{v_target} = $target
		if $target && ($downgrades
			|| ! $p->{v_target}
			|| $p->{versions}{$target}{version_idx} <
				$p->{versions}{$p->{v_target}}{version_idx});
}

my ($http_total_size, $http_start, $http_end);
sub http_get {
	my ($url, $file, $total_size, $sub) = @_;
	$url =~ s{(?<=[^:])//+}{/}g;
	print "get $url\n"
		if $debug;
	(my $name = $url) =~ s{^.*/}{};

	state $ua = get_user_agent();
	state $idx = 0;
	$idx++;

	my $fh;
	(my $dir = $file) =~ s{[^/]+$}{};
	mkdir_p($dir);
	unless (open $fh, '>', "$file.new") {
		print STDERR "E: Could not write $file.new: $!\n";
		exit 10;
	}

	my $req = HTTP::Request->new(GET => $url);

	my $data;
	my $size = 0;
	my $start = time;
	$http_start = $start
		unless $http_start && $http_start < $start;
	my $res = $ua->request($req, sub {
		my ($data) = @_;
		$data = $sub->($data)
			if $sub;
		print $fh $data;

		state $last = 0;
		my $res = $_[1];
		$total_size = $res->header('Content-Length') // -1
			unless defined $total_size;
		$size += length($_[0]);

		my $now = time;
		return
			unless $now - $last > 0.1;
		$last = $now;

		my $s;
		unless ($size || $total_size) {
			$s = 'Waiting for headers';
		} elsif ($total_size > 0) {
			$s = sprintf("%s/%s %d%%",
				size2t($size), size2t($total_size),
				100 * $size / $total_size);
		} else {
			$s = size2t($size);
		}
		print "[$idx $name $s]\r";
	});

	# flush
	$sub->(undef)
		if $sub;

	close($fh);
	my $end = time;
	$http_end = $end
		unless $http_end && $http_end > $end;

	if ($res->is_success) {
		rename("$file.new", $file);
		print "Get:$idx $url\n";
		$http_total_size //= 0;
		$http_total_size += $total_size // $size;
		return $total_size // $size;
	} else {
		print "Err:1 $url\n ", $res->message, "\n";
		unlink("$file.new");
		print STDERR "W: Failed to fetch $url ", $res->message, "\n";
		return 0;
	}
}

sub http_done {
	printf "Fetched %s in %ds (%s/s)\n",
		size2t($http_total_size), $http_end - $http_start,
		size2t($http_total_size / ($http_end - $http_start));
}

sub get_user_agent {
	my $ua = LWP::UserAgent->new(
		agent => "cygapt/".VERSION
	);
	$ua->proxy(['http', 'https', 'ftp']
		=> "http://".$setup{net_proxy_host}[0]
			.":".$setup{net_proxy_port}[0])
		if exists $setup{net_proxy_host}
		&& exists $setup{net_proxy_port};
	$ua->env_proxy;
	return $ua;
}

sub uri_escape {
	my ($d) = @_;
	$d =~ s{([:/])}{sprintf("%%%02x", ord($1))}ge;
	return $d;
}

sub v2va {
	# split into groups of non-digits and digits
	# first is a group of digits
	return [ defined $_[0] ? split(/(\d+)/, $_[0]) : ('') ]
}

sub vacmp {
	my ($a, $b) = @_;
	my $i = 0;

	while(1) {
		last
			unless $i < @$a && $i < @$b;
		my $cmp = $a->[$i] cmp $b->[$i];
		return $cmp
			if $cmp;
		$i++;

		last
			unless $i < @$a && $i < @$b;
		$cmp = $a->[$i] <=> $b->[$i];
		return $cmp
			if $cmp;
		$i++;
	}

	if (@$a == @$b) {
		return 0;
	} elsif ($i < @$a) {
		return +1;
	} else {
		return -1;
	}
}

sub argv2re {
	return (undef, [], [])
		unless @_;

	my $opt = @_ && ref $_[0] eq 'HASH' ? shift @_ : { };
	my (@re, @t_rel, @t_ver);
	for (@_) {
		if (! $opt->{installed}) {
		} elsif (m{[=/](\S+)}) {
			print STDERR "E: Can only match installed ",
				"version: $_\n";
			exit 10;
		}
		print STDERR "W: Only select target version or release: $_\n"
			if m{/} && m{=};

 		push @t_rel, s{/(\S+)$}{} ? glob2re($1) : $target_release;
		push @t_ver, s{=(\S+)$}{} ? glob2re($1) : undef;

		push @re, glob2re($_)."(?{ \$a = ".scalar(@re)." })";
	}

	my $re;
	use re 'eval';
	$re = join('|', @re);
	$re = qr/(?:$re)/;
	print STDERR "Match: $re\n"
		if $debug;

	return ($re, \@t_rel, \@t_ver);
}

sub glob2re {
	my ($re) = @_;
	$re = glob_to_regex($re);
	return qr{$re};
}

sub mkdir_p {
	my ($dir) = @_;
	return
		if -d $dir;
	(my $up = $dir) =~ s{/[^/]*$}{};
	mkdir_p($up);
	mkdir $dir;
}

sub size2t {
	my ($s) = @_;
	state $fmt = [
		[ "%d B", 1, ],
		[ "%.1f kB", 1024, ],
		[ "%d kB", 1024, ],
		[ "%.1f MB", 1024 * 1024, ],
		[ "%d MB", 1024 * 1024, ],
		[ "%.1f GB", 1024 * 1024 * 1024, ],
		[ "%d GB", 1024 * 1024 * 1024, ],
	];

	my $t;
	for my $i (0..$#$fmt) {
		my $t2 = sprintf($fmt->[$i][0], $s / $fmt->[$i][1]);
		($t = $t2), last
			unless length($t2) > 7;
	}
	$t //= sprintf($fmt->[-1][0], $s / $fmt->[-1][1]);

	# thousands separator
	$t =~ m{(\d+)};
	my $n = $1;
	my $n2 = reverse join(",", unpack("(A3)*", reverse $n));
	$t =~ s{$n}{$n2};

	return $t;
}

sub usage {
	print STDERR @_, "\n"
		if @_;
	print STDERR <<USAGE;
Usage: cygapt [options] command

cygapt is a commandline package manager for Cygwin, that tries to provide
a similar interface as APT on Debian.

Commands:
  list - list packages based on package names
  install - install packages
  remove - remove packages
  update - update list of available packages
  upgrade - upgrade the system by installing/upgrading packages

Options:
  -y, --yes
  -v, --verbose
  -h, --help
USAGE

	exit @_ ? 10 : 0;
}

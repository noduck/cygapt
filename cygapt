#!/usr/bin/perl

use strict;
use warnings;
use feature qw(:5.20);
use Getopt::Long qw(:config bundling no_ignore_case);
use Fcntl qw(:flock SEEK_SET SEEK_END);
use LWP;
use POSIX qw();
use Compress::Zlib;
use Compress::Bzip2;
use POSIX qw(uname);
use Time::HiRes qw(time sleep);
use Term::ReadKey;
use HTTP::Date qw(time2str str2time);
use Digest::SHA;
use Digest::MD5;
use DynaLoader;
use Data::Dumper;



use constant {
	SETUP => "/etc/setup/setup.rc",
	INSTALLED => "/etc/setup/installed.db",
	# not using the cache from setup.ini
	CACHE => "/var/cache/cygapt",
	LOG => "/var/log/cygapt.log",
	VERSION => "0.5",
};
my %setup;
my %package = ( cygapt => {
	name => 'cygapt',
	installed => 1,
	v_installed => VERSION,
	v_target => VERSION,
	v_latest => VERSION,
	tag_category => qw(Base),
	tag_ldesc => 
"cygapt is a commandline package manager for Cygwin, that tried to provide
a similar interface as APT on Debian. cygapt currently supports:
-installing packages
-removing packages
-upgrading packages
-automatically removing packages that are no longer needed LDESC",
	tag_sdesc => 'package manager for Cygwin, similar to Debian APT',
	picked => 0,
});

my $v = $package{cygapt}{versions}{"".VERSION} = {
	tag_version => VERSION,
	va => v2va(VERSION),
	version_idx => 0,
	releases => [ 'curr', 'now' ],
	deps => [qw(perl-Compress-Bzip2
		perl-Digest-SHA perl-Scalar-List-Utils
		perl-TermReadKey perl-libwww-perl)],
	installed => 1,
};
$v->{tag_depends2} = join(", ", @{$v->{deps}});
$package{cygapt}{tag_requires} = join(" ", @{$v->{deps}});
$package{cygapt}{versions_sorted} = [ $v ];

# fields in order (not showing install and source)
my @field = (qw(sdesc ldesc category requires version depends2));

my ($dryrun, $verbose, $help);
my $debug = 0;
my $root = '';
# there may be scenarios were we end up overwriting our own dependencies (DLLs)
# and as a result can no longer fork (cygwin limitation), at that time we
# should try to restart
my $restart_needed;

my %common_opt = (
	"s|simulate|n|dry-run" => \$dryrun,
	"v|verbose"	=> \$verbose,
	"D|debug:+"	=> \$debug,
	"h|help"	=> \$help,
	"root=s"	=> \$root,
);

my ($installed, $upgradable, $allversions, $target_release, $downgrades, $yes,
	$downloadonly, $reinstall, $combine_or, $recurse, $fullrecurse);

my @command = (
	list => {
		opts => {
			"i|installed"	=> \$installed,
			"u|upgradable|upgradeable" => \$upgradable,
			"a|all-versions" => \$allversions,
			"t|target=s"	=> \$target_release,
			"downgrades|allow-downgrades" => \$downgrades,
		},
		help => <<HELP,
Usage: cygapt [options] list {package{=version|/release}}...

list all packages based on package names

Options for list:
  -i, --installed	only list installed packages
  -u, --upgradable	only list upgradable packages
  -a, --all-versions	list all available versions
  -t, --target=RELEASE	select version from this RELEASE
  --allow-downgrades	allow selecting versions before the installed version
HELP
		sub => sub {
			$| = 1;
			print "Listing... ";
			get_available(\'quiet');
			get_installed(\'quiet');
			print "Done\n";
			list({ upgradable => $upgradable,
				installed => $installed,
				all => $allversions },
				@_);
		},
	},


	show => {
		opts => {
			"i|installed"	=> \$installed,
			"u|upgradable|upgradeable" => \$upgradable,
			"a|all-versions" => \$allversions,
			"t|target=s"	=> \$target_release,
			"downgrades|allow-downgrades" => \$downgrades,
		},
		help => <<HELP,
Usage: cygapt [options] show package{=version|/release}...

show package details

Options for show:
  -i, --installed	only show installed packages
  -u, --upgradable	only show upgradable packages
  -a, --all-versions	show all available versions
  -t, --target=RELEASE	select version from this RELEASE
  --allow-downgrades	allow selecting versions before the installed version
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No packages found\n";
				exit 10;
			}
			get_installed(\'quiet');
			get_available(\'quiet');
			list({ show => 1, upgradable => $upgradable,
				installed => $installed,
				all => $allversions},
				@_);
		},
	},


	update => {
		help => <<HELP,
Usage: cygapt [options] update

update list of available packages
HELP
		sub => sub {
			if (@ARGV) {
				print STDERR "E: The update command ",
					"takes no arguments\n";
				exit 10;
			}
			update();
		},
	},


	upgrade => {
		opts => {
			"t|target=s"	=> \$target_release,
			"downgrades|allow-downgrades" => \$downgrades,
			"y|yes"		=> \$yes,
			"d|download-only" => \$downloadonly,
		},
		help => <<HELP,
Usage: cygapt [options] upgrade {package{=version|/release}}...

upgrade the system by installed/upgrading packages

WARNING: upgrading certain library packages may result in cygapt aborting,
or looping trying to clone. If this happens, break the running process, and
try to restart.

Options for upgrade:
  -t, --target=RELEASE	select version from this RELEASE
  --allow-downgrades	allow selecting versions before the installed version
  -y, --yes		assume yes answer
  -d, --download-only	only download packages, do not upgrade
HELP
		sub => sub {
			get_available();
			build_tree();
			get_installed();

			my $changes = upgradable({ install => 0 }, @ARGV);
			make_changes($changes)
				if $changes;
		},
	},


	install => {
		opts => {
			"t|target=s"	=> \$target_release,
			"downgrades|allow-downgrades" => \$downgrades,
			"y|yes"		=> \$yes,
			"d|download-only" => \$downloadonly,
			"reinstall"	=> \$reinstall,
		},
		help => <<HELP,
Usage: cygapt [options] install package{=version|/release}...

install packages

Options for install:
  -t, --target=RELEASE	select version from this RELEASE
  --allow-downgrades	allow selecting versions before the installed version
  -y, --yes		assume yes answer
  -d, --download-only	only download packages, do not install
  --reinstall		reinstall package, even if already installed

WARNING: be careful installing older versions (--allow-downgrades), as
Cygwin dependencies are not versioned. Packages depending on the downgraded
package may not get downgraded leading to broken system.
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: The install command ",
					"should have at least one arguments\n";
				exit 10;
			}

			get_available();
			build_tree();
			get_installed();

			my $changes = upgradable({ install => 1 }, @ARGV);
			make_changes($changes)
				if $changes;
		},
	},


	remove => {
		opts => {
			"y|yes"		=> \$yes,
		},
		help => <<HELP,
Usage: cygapt [options] remove package...

remove packages

Options for remove:
  -y, --yes		assume yes answer
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: The remove command ",
					"should have at least one arguments\n";
				exit 10;
			}

			get_available();
			build_tree();
			get_installed();

			my $opt = { print => 0 };
			exit 10
				unless list_rdepends($opt, @ARGV);
			my $u = $opt->{installed_level};
			make_changes({
				removes => [ sort { $u->{$b} <=> $u->{$a} }
					keys %$u ],
			});
		},
	},


	autoremove => {
		help => <<HELP,
Usage: cygapt [options] autoremove

remove all unused packages
HELP
		sub => sub {
			if (@ARGV) {
				print STDERR "E: The autoremove command ",
					"takes no arguments\n";
				exit 10;
			}

			get_available();
			build_tree();
			get_installed();
			my $rems = autoremove();
			make_changes({ removes => $rems });
		},
	},

	fix => {
		help => <<HELP,
Usage: cygapt [options] fix

fixes installation: finds missing dependencies, and installed packages without
file listing (/etc/setup/<package>.list).
HELP
		sub => sub {
			if (@ARGV) {
				print STDERR "E: The autoremove command ",
					"takes no arguments\n";
				exit 10;
			}

			get_available();
			build_tree();
			get_installed();
			my $changes = fix();
			make_changes($changes);
		},
	},

	clean => {
		help => <<HELP,
Usage: cygapt [options] clean

clears out the local copy of downloaded package files
HELP
		sub => sub {
			if (@ARGV) {
				print STDERR "E: The clean command ",
					"takes no arguments\n";
				exit 10;
			}

			clean();
		},
	},


	depends => {
		opts => {
			"r|recurse"	=> \$recurse,
			"full-recurse"	=> \$fullrecurse,
			"i|installed"	=> \$installed,
			"t|target=s"	=> \$target_release,
			"downgrades|allow-downgrades" => \$downgrades,
		},
		help => <<HELP,
Usage: cygopt [options] depends package{=version|/release}...

list dependencies of packages, defaults to dependencies for target version

Options for depends:
  -r, --recurse		recurse into dependencies until an installed package
  --full-recurse	recurse through all dependencies
  -i, --installed	show dependency of installed version
  -t, --target=RELEASE	select version from this RELEASE
  --allow-downgrades	allow selecting versions before the installed version
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No packages found\n";
				exit 10;
			}

			get_available();
			build_tree();
			get_installed();
			list_depends({
					recurse => $recurse ? ~0 : 1,
					fullrecurse => $fullrecurse ? ~0 : 1,
					installed_version => $installed,
				},@ARGV);
		},
	},


	rdepends => {
		help => <<HELP,
Usage: cygopt [options] rdepends package...

list reverse dependencies of packages

Options for rdepends:
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No packages found\n";
				exit 10;
			}

			get_available();
			build_tree();
			get_installed();
			list_rdepends(@ARGV);
		},
	},


	search => {
		opts => {
			"or"		=> \$combine_or,
		},
		help => <<HELP,
Usage: cygapt [options] search words

search package descriptions for the words
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No search words found\n";
				exit 10;
			}

			get_available();
			#get_installed();
			search({ combine => $combine_or ? "||" : "&&" },
				@ARGV);
		},
	},


	find => {
		help => <<HELP,
Usage: cygapt [options] find file...

find the packages that contain the file
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No files provided\n";
				exit 10;
			}

			get_installed();
			find(@ARGV);
		},
	},


	files => {
		help => <<HELP,
Usage: cygapt [options] files package...

list the files that belong to the packages
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No packages provided\n";
				exit 10;
			}

			get_installed();
			files(@ARGV);
		},
	},


	mark_manual => {
		help => <<HELP,
Usage: cygapt [options] mark-manual package...

mark the packages as manually installed
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No packages provided\n";
				exit 10;
			}

			get_installed();
			mark(1, @ARGV);
		},
	},


	mark_automatic => {
		help => <<HELP,
Usage: cygapt [options] mark-automatic package...

mark the packages as automatically installed
HELP
		sub => sub {
			unless (@ARGV) {
				print STDERR "E: No packages provided\n";
				exit 10;
			}

			get_installed();
			mark(0, @ARGV);
		},
	},


	vcmp => {
		sub => sub {
			my $a = v2va($ARGV[0]);
			my $b = v2va($ARGV[1]);
			my $cmp = vacmp($a, $b);
			print "$ARGV[0] ",
				($cmp > 0 ? ">" : $cmp < 0 ? "<" : "=="),
				" $ARGV[1]\n";
		},
	},
);
my %command = @command;

# aliases and hidden commands
$command{deps} = $command{depends};
$command{rdeps} = $command{rdepends};
$command{dist_upgrade} = $command{upgrade};
$command{auto_remove} = $command{autoremove};
$command{my_deps}{sub} = \&my_deps;
$command{restart}{sub} = \&do_restart;

my %all_opts = %common_opt;
for my $c (values %command) {
	while (my ($k, $v) = each %{$c->{opts}}) {
		$all_opts{$k} = $v;
	}
}

my $color;
if (-t STDOUT) {
	eval "use Term::ANSIColor";
	$color = 1
		unless $@;
}

# ignore all opts and find command
my $cmd;
do {
	local @ARGV = @ARGV;
	GetOptions(%all_opts) or usage("");
	$cmd = shift @ARGV;
};
usage($help ? () : "")
	unless $cmd;
$cmd =~ s/-/_/g;
unless (exists $command{$cmd}) {
	if ($cmd eq 'help') {
		$cmd = $ARGV[1];
		$cmd =~ s/-/_/g;
		if ($cmd) {
			usage_cmd($cmd);
		} else {
			usage();
		}
	}


	print STDERR "E: Invalid command $cmd\n";
	exit 10;
}
usage_cmd($cmd)
	if $help;

# parse opts for the command (using original ARGV)
$debug = 0;
GetOptions(%common_opt, %{$command{$cmd}{opts}})
	or usage_cmd($cmd, "");

# initialize
if (! $root) {
} elsif (! -d $root) {
	print STDERR "E: root directory $root is not accessible: $!\n";
	exit 10;
} elsif ($root =~ s{/+$}{}) {
}
if ($target_release) {
	$target_release = "{$target_release}"
		if $target_release =~ /,/ && $target_release !~ /{/;
	$target_release = glob2re($target_release);
}
get_setup();

# execute command
shift @ARGV;
logger("cygapt $cmd @ARGV");
$command{$cmd}{sub}->(@ARGV);

exit 0;



sub list {
	my $opt = { };
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';

	# do not need to be strict on list/show with preventing downgrades
	$downgrades = 1;
	my ($re, $t_rels, $t_vers) = argv2pack_re(@_);

	my $count = 0;
	for my $pack (sort keys %package) {
		$a = undef;
		next
			if $re && $pack !~ $re;
		my $p = $package{$pack};
		next
			if ($opt->{installed} || $opt->{upgradable})
			&& ! $p->{v_installed};

		select_package_versions($p,
			defined $a ? $t_rels->[$a] : $target_release,
			defined $a ? $t_vers->[$a] : undef);

		# upgradable needs to be installed, and not the upgrade
		# version
		next
			if $opt->{upgradable}
			&& (! $p->{v_installed}
				|| ! $p->{v_target}
				|| $p->{v_installed} eq $p->{v_target});

		print Dumper($p)
			if $debug > 1;

		$count++;
		if ($opt->{count_only}) {
			$opt->{upgrades}{$pack}++;
			next;
		}

		my $u_t;
		if ($opt->{show}) {
			print "@ $pack\n";
			for my $f (@field) {
				next
					unless exists $p->{"tag_$f"};
				print "$f: ", $p->{"tag_$f"}, "\n";
			}
		} elsif ($p->{v_target} && $p->{v_installed}) {
			# upgrade or downgrade?
			$u_t =  $p->{versions}{$p->{v_target}}{version_idx}
				< $p->{versions}{$p->{v_installed}}{version_idx}
				? 'upgradable' : 'downgradable'
		}

		my $first = 1;
		for my $v ($opt->{all}
			? @{$p->{versions_sorted}}
			: $p->{versions}{$p->{v_target}}) {
			if ($opt->{show}) {
				print "[", join(",", @{$v->{releases}}), "]\n"
					unless $first;

				for my $f (@field) {
					next
						unless exists $v->{"tag_$f"};
					print "$f: ", $v->{"tag_$f"}, "\n";
				}

				print "status: ",
					$p->{picked} ? "manually installed"
						: "automatically installed",
					"\n"
					if $opt->{all} && $v->{installed}
					|| ! $opt->{all} && $p->{v_installed};

				$first = undef;
				next;
			}

			my @t;
			push @t, 'installed'
				if $v->{installed} && ! $opt->{show};

			push @t, "$u_t from: $p->{v_installed}"
				if $p->{v_installed} && ! $v->{installed}
				&& $p->{v_target}
				&& $v->{tag_version} eq $p->{v_target};
			push @t, "$u_t to: $p->{v_target}"
				if $v->{installed}
				&& $p->{v_target}
				&& $v->{tag_version} ne $p->{v_target};

			print "$pack/", join(",", @{$v->{releases}}),
				" ", $v->{tag_version},
				@t ? " [".join(",", @t)."]" : "",
				"\n";
		}

		print "\n"
			if $opt->{all} || $opt->{show};
	}

	return $count;
}

sub update {
	http_start(undef, scalar @{$setup{last_mirror}});
	for my $mirror (@{$setup{last_mirror}}) {
		update_mirror($mirror);
	}

	http_done();

	$| = 1;
	print "Reading state information... ";
	get_installed(\'quiet');
	get_available(\'quiet');
	my $u = list({ count_only => 1, upgradable => 1});
	print "Done\n";
	print "$u packages can be upgraded. ",
		"Run 'cygapt list --upgradable' to see them.\n"
		if $u;
}

sub update_mirror {
	my ($mirror) = @_;
	local $| = 1;

	my $url = $mirror.'/'.$setup{arch}.'/setup.bz2';
	my $file = $root.join("/", CACHE, uri_escape($mirror),
		$setup{arch}, "setup.ini");

	my ($bz, $bzstat) = bzinflateInit;
	my $res = http_get($url, $file, undef, undef, sub {
		if (defined $_[0]) {
			my ($data, $bzstat) = $bz->bzinflate($_[0]);
			return $data;
		} else {
			my ($data, $bzstat) = $bz->bzflush;
			my $t = $data // '';
			($data, $bzstat) = $bz->bzclose;
			return $t.($data // '');
		}
	});

	unless ($res) {
		exit 10;
	}
}

sub make_changes {
	my ($changes) = @_;
	$changes->{installs} //= [];
	$changes->{install_deps} //= [];
	$changes->{upgrades} //= [];
	$changes->{upgrade_deps} //= [];
	$changes->{removes} //= [];
	$changes->{remove_rdeps} //= [];

	my $nc = @{$changes->{installs}}
		+ @{$changes->{install_deps}}
		+ @{$changes->{upgrade_deps}};
	my $uc = @{$changes->{upgrades}};
	my $rc = @{$changes->{removes}}
		+ @{$changes->{remove_rdeps}};

	my @base = grep { ($package{$_}{tag_category} // '')
			=~ /(?:^|\s)Base(?:\s|$)/ }
		@{$changes->{removes}}, @{$changes->{remove_rdeps}};
	if (@base) {
		print "Refusing to remove base packages:\n";
		print_array(@base);
		exit 10;
	}

	my %upgrade = (count_only => 1, upgradable => 1);
	# upgradables should be without target release
	$target_release = undef;
	list(\%upgrade);
	my $us = $upgrade{upgrades};
	for my $pack (@{$changes->{installs}},
			@{$changes->{install_deps}},
			@{$changes->{upgrades}},
			@{$changes->{upgrade_deps}},
			@{$changes->{removes}},
			@{$changes->{remove_deps}}) {
		delete $us->{$pack};
	}
	my $nuc = scalar keys %$us;

	my $ask;
	lock_installed();

	# deps for install
	if (@{$changes->{install_deps}}) {
		print "The following additional packages will be installed:\n";
		print_array(sort @{$changes->{install_deps}});
		$ask = 1;
	}
	# anything new to install (explicitly install, deps for install/upgrade)
	if ($nc) {
		print "The following NEW packages will be installed:\n";
		print_array(sort(@{$changes->{installs}},
			@{$changes->{install_deps}},
			@{$changes->{upgrade_deps}}));
		$ask = 1
			if @{$changes->{upgrade_deps}};
	}
	# upgrades
	if ($uc) {
		print "The following packages will be upgraded:\n";
		print_array(sort @{$changes->{upgrades}});
		$ask = 1;
	}
	# removes (explicit remove, and rdepends)
	if ($rc) {
		print "The following packages will be REMOVED:\n";
		print_array(sort(@{$changes->{removes}},
			@{$changes->{remove_rdeps}}));
		$ask = 1;
	}

	print "$uc upgraded, $nc newly installed, $rc to remove and ",
		"$nuc not upgraded.\n";
	return
		unless $uc || $nc || $rc;

	my @get;
	my $files;
	my ($get_size, $total_size) = (0, 0);
	for my $pack (sort @{$changes->{installs}},
			@{$changes->{install_deps}},
			@{$changes->{upgrade_deps}},
			@{$changes->{upgrades}}) {
		my $p = $package{$pack};
		unless ($p->{v_target}) {
			print STDERR "E: no target version was ",
				"selected for $pack\n";
			exit 10;
		}

		my $v = $p->{versions}{$p->{v_target}};
		if (exists $v->{local_file}) {
			$files->{$pack} = $v->{local_file};
			$total_size += -s $v->{local_file};
			next;
		} elsif (! $v->{tag_install}) {
			print STDERR "E: Cannot install package $pack ",
				"version $p->{v_target}: no downloadable ",
				"copy found\n";
			exit 10;
		}
		my @install = split /\s+/, $v->{tag_install};
		my $file = $root.join("/", CACHE, uri_escape($v->{base}),
			$install[0]);
		$files->{$pack} = $file;
		$total_size += $install[1];
		next
			if -f $file;

		push @get, {
			url => $v->{base}.$install[0],
			file => $file,
			size => $install[1],
			hash => $install[2],
		};
		$get_size += $install[1];
	}
	print "Need to get ",
		$total_size == $get_size ?  size2t($get_size)
		: size2t($get_size)."/".size2t($total_size),
		" of archives.\n";
	# Cygwin does not provide information about installed size
	# print "After this operation, ", ...
	#	? "232 kB of additional disk space will be used.\n"
	#	: "13.1 MB disk space will be freed.\n";

	if (($ask || $changes->{ask}) && ! $yes) {
		local $| = 1;
		print "Do you want to continue? [Y/n] ";
		$_ = <STDIN>;
		return
			unless $_ =~ /^\s*(?:y.*)?\s*$/;
	}

	http_start($total_size, scalar @get);
	if (@get) {
		my $c = 0;
		for my $g (@get) {
			if ($dryrun) {
				$c++;
				print "Get $g->{file}\n";
				next;
			}

			$c++
				if http_get($g->{url}, $g->{file},
					$g->{size}, $g->{hash});
		}
		if ($c == @get) {
			http_done();
		} else {
			print STDERR "E: could not download all packages.\n";
			exit 10;
		}
	}

	if ($downloadonly) {
		print "Download complete and in download only mode\n";
		return;
	}

	make_changes2($changes, $files);
}

sub make_changes2 {
	my ($changes, $files) = @_;

	safeguard_dlls();

	while(my $pack = shift @{$changes->{install_deps}}) {
		do_install($pack, $package{$pack}{v_target},
			$files->{$pack}, 0);
	}
	while(my $pack = shift @{$changes->{upgrade_deps}}) {
		do_install($pack, $package{$pack}{v_target},
			$files->{$pack}, 0);
	}
	while(my $pack = shift @{$changes->{upgrades}}) {
		do_upgrade($pack, $package{$pack}{v_installed},
			$package{$pack}{v_target}, $files->{$pack});
	}
	while(my $pack = shift @{$changes->{installs}}) {
		do_install($pack, $package{$pack}{v_target},
			$files->{$pack}, 1);
	}

	safeguard_dlls();
	restart_changes($changes, $files)
			if $restart_needed;

	# run all postinstall
# TODO: run them by order of depends?
	for my $post (glob("$root/etc/postinstall/*.sh")) {
		(my $pack = $post) =~ s{^.*/}{};
		$pack =~ s{\.sh$}{}i;
		my $vers;
		if (exists $package{$pack} && $package{$pack}{v_target}) {
			$vers = $package{$pack}{v_target};
		} else {
			my ($p) = find(substr($post, length($root)));
			$pack = $p
				if $p;
			$vers = $p ? $package{$pack}{v_installed}
				: '0.0';
		}
		logger("set up $pack $vers");
		print "Setting up $pack ($vers) ...\n";
		print "running $post\n"
			if $debug;

		$post =~ s{^$root}{};
		my $rc = system($root ? ('chroot', "$root/") : (), $post);
		rename($root.$post, "$root$post.done")
			unless $rc;
	}

	# run preremove for packages to be removed
	for my $pack (@{$changes->{remove_rdeps}},
			@{$changes->{removes}}) {
		my $pre = "/etc/preremove/$pack.sh";
		next
			unless -f $root.$pre;

		print "running $pre\n"
			if $debug;
		my $rc = system($root ? ('chroot', "$root/") : (), $pre);
		rename($root.$pre, "$root$pre.todo")
			if $rc;
	}

	while(my $pack = shift @{$changes->{remove_rdeps}}) {
		do_remove($pack);
	}
	while(my $pack = shift @{$changes->{removes}}) {
		do_remove($pack);
	}

	unlock_installed();
}

sub restart_changes {
	my ($changes, $files) = @_;

	print "\n";

	my @exe = ($0, 'restart');
	push @exe, "-D$debug"
		if $debug;
	push @exe, "-v"
		if $verbose;

	for my $k (qw(install_deps upgrade_deps upgrades installs remove_rdeps
		removes)) {
		next
			unless @{$changes->{$k}};
		push @exe, "$k:",
			map join(":", $_, $package{$_}{v_target}, $files->{$_}),
				@{$changes->{$k}};
	}

	print "Restart: @exe\n"
		if $debug;
	{ exec @exe };
	print STDERR "E: Could not restart: $!\n";
	exit 10;
}

sub do_restart {
	print "RESTART: @ARGV\n"
		if $debug;

	get_installed();
	lock_installed();

	my $k;
	my ($changes, $files);
	while(my $a = shift @ARGV) {
		if ($a =~ m{^(install_deps|upgrade_deps|upgrades|installs
			|remove_rdeps|removes):$}x) {
			$k = $1;
			next;
		} elsif (! $k || $a !~ /:.*:/) {
			print STDERR "E: unexpected arguments: @ARGV\n";
			exit 10;
		}

		my ($pack, $vers, $f) = split /:/, $a, 3;
		push @{$changes->{$k}}, $pack;
		$package{$pack}{v_target} = $vers;
		$files->{$pack} = $f;
	}

	make_changes2($changes, $files);
}

sub do_install {
	my ($pack, $vers, $tar, $picked) = @_;

	(my $fname = $tar) =~ s{^.*/}{};
	logger("unpack $pack $vers");
	print "Preparing to unpack .../$fname ...\n";

	my $lst_fh;
	my $lst_name = "$root/etc/setup/$pack.lst.gz";
	unless ($dryrun) {
		unless ($lst_fh = gzopen($lst_name, 'wb')) {
			print STDERR "E: Cannot write $lst_name: $!\n";
			exit 10;
		}
	}

	print "Unpacking $pack ($vers) ...\n";
	if ($dryrun) {
		print "\tdryrun\n";
		return;
	}
	do_extract($tar, $lst_fh);
	$lst_fh->gzclose;

	my $p = $package{$pack};
	$p->{v_installed} = $vers;
	$p->{versions}{$p->{v_installed}}{installed} = 1;
	$p->{picked} = $picked;
	write_installed();
}

sub do_upgrade {
	my ($pack, $old_vers, $new_vers, $tar) = @_;

	(my $fname = $tar) =~ s{^.*/}{};
	logger("unpack $pack $new_vers over $old_vers");
	print "Preparing to unpack .../$fname ...\n";

	my %old_file;
	my $lst_fh;
	my $lst_name = "$root/etc/setup/$pack.lst.gz";
	if ($lst_fh = gzopen($lst_name, 'rb')) {
		my $line;
		while($lst_fh->gzreadline($line)) {
			chomp($line);
			$old_file{$line}++;
		}
		$lst_fh->gzclose;
	}
	rename($lst_name, "$lst_name.old");

	unless ($dryrun) {
		unless ($lst_fh = gzopen($lst_name, 'wb')) {
			print STDERR "E: Cannot write $lst_name: $!\n";
			exit 10;
		}
	}

	print "Unpacking $pack ($new_vers) over ($old_vers) ...\n";
	if ($dryrun) {
		print "\tdryrun\n";
		return;
	}

	do_extract($tar, $lst_fh, sub {
		# file still present
		delete $old_file{$_};
	});
	$lst_fh->gzclose;

	# delete remaining files that are not present in upgraded version
	for my $file (sort { $b cmp $a } keys %old_file) {
		if ($file =~ m{^etc/postinstall/.*\.sh$}) {
			unlink "$root/$file";
			unlink "$root/$file.done";
		} elsif ($file =~ m{/$}) {
# TODO: if rmdir fails, that may be because of a safeguard, should
# try again after cleanup of safeguards
			rmdir "$root/$file";
		} else {
			unlink "$root/$file";
		}
	}

	my $p = $package{$pack};
	$p->{v_installed} = $new_vers;
	delete $p->{versions}{$old_vers}{installed};
	$p->{versions}{$new_vers}{installed} = 1;
	write_installed();
	unlink("$lst_name.old");
}

sub do_extract {
	my ($tar, $lst_fh, $sub) = @_;
	my $my_dlls = my_dlls();

	my $tar_fh;
	my @exec = ('tar', '-C', "$root/",
		$tar =~ m{\.gz} ? '--gzip'
			: $tar =~ m{\.bz2} ? '--bzip2'
			: $tar =~ m{\.xz} ? '--xz'
			: (),
		'-vxf', $tar);
	print STDERR "Extract: @exec\n"
		if $debug;

	eval {
		POSIX::sigaction(POSIX::SIGALRM, POSIX::SigAction->new(
			sub { die "Alarm"; },
			0, POSIX::SA_SIGINFO));
		eval {
			#alarm(2);
			unless (open $tar_fh, '-|', @exec) {
				print STDERR "E: Cannot start tar $tar: $!\n";
				exit 10;
			}
			alarm(0);
		};
		die $@ if $@;
	};
	if (! $@) {
	} elsif ($@ =~ /Alarm/) {
		print STDERR "E: Failed to start tar to extract $tar\n";
		print STDERR "Please restart cygapt\n";
		exit 10;
	} else {
		die $@;
	}

	while(<$tar_fh>) {
		$lst_fh->gzwrite($_);
		print $_
			if $debug;
		chomp;
		$sub->($_)
			if $sub;
	}
	safeguard_dlls('update');

	close($tar_fh);
}

sub do_remove {
	my ($pack) = @_;
	my $p = $package{$pack};

	logger("removing $pack $p->{v_installed}");
	print "Removing $pack ($p->{v_installed}) ...\n";

	if ($dryrun) {
		print "\tdryrun\n";
		return;
	}

	my $lst_fh;
	my $lst_name = "$root/etc/setup/$pack.lst.gz";
	if ($lst_fh = gzopen($lst_name, 'rb')) {
		my $line;
		while($lst_fh->gzreadline($line)) {
			chomp($line);
			if ($line =~ m{^etc/postinstall/.*\.sh$}) {
				unlink "$root/$line";
				unlink "$root/$line.done";
			} elsif ($line =~ m{/$}) {
				rmdir "$root/$line";
			} else {
				unlink "$root/$line";
			}
		}
		$lst_fh->gzclose;
		unlink($lst_name);
	} elsif ($pack ne 'cygapt') {
		print STDERR "W: Cannot read $lst_name: $!\n";
	}

	delete $p->{versions}{$p->{v_installed}}{installed};
	delete $p->{v_installed};
	delete $p->{picked};
	write_installed();
}

sub safeguard_dlls {
	state $dlls;

	if (! $dlls) {
		# initialize
		$dlls = my_dlls();
		for my $dll (keys %$dlls) {
			if ($dll =~ m{^/cygdrive/c/}) {
				delete $dlls->{$dll};
				next;
			}
			print STDERR "Keeping safeguard of $dll\n"
				if $debug;
			$dlls->{$dll} = {
				dll => $dll,
				inode => (stat $dll)[1],
				safeguard => "$dll.cygapt_safeguard",
			};
			unlink($dlls->{$dll}{safeguard});
			link($dll, $dlls->{$dll}{safeguard});
		}
	} elsif (! @_) {
		for my $dll (keys %$dlls) {
			if ($dlls->{$dll}{safeguard}) {
				print STDERR "Deleting safeguard of $dll\n"
					if $debug;
				unlink($dlls->{$dll}{safeguard});
			}
			if ($dlls->{$dll}{new}) {
				print STDERR "Installing new $dll\n"
					if $debug;
				rename($dlls->{$dll}{new}, $dll);
				$restart_needed = 1;
			}
			if ($dlls->{$dll}{delete}) {
				print STDERR "Deleting removed $dll\n"
					if $debug;
				unlink($dlls->{$dll}{delete});
			}
		}
	} elsif ($_[0] eq 'update') {
		for my $dll (keys %$dlls) {
			# dll is no longer linked to safeguard, or gone
# TODO: doesn't find DLLs that are removed?
# e.g. perl 5.26 => 5.22 should find deleted DLLs under 
# usr/lib/perl5/5.26/x86_64-cygwin-threads/auto
			my $inode = (stat $dll)[1];
			next
				if defined $inode
				&& $inode == $dlls->{$dll}{inode};
			if (! defined $inode) {
				$dlls->{$dll}{delete} = $dll;
				print STDERR "Restoring deleted version with ",
					"safeguard of $dll\n"
					if $debug;
			} else {
				$dlls->{$dll}{new} = "$dll.cygapt_new";
				print STDERR "Replacing new version with ",
					"safeguard of $dll\n"
					if $debug;
				rename($dll, $dlls->{$dll}{new});
			}
			link($dlls->{$dll}{safeguard}, $dll);
		}
	}
}

sub clean {
	system('find', $root.CACHE,
		qw(-follow -maxdepth 3 -name release -type d -exec rm -r {} ;));
}

sub autoremove {
	my %todo = %package;
	my %needed;
	my @remove;

	while(keys %todo) {
		my $before_count = scalar keys %todo;

PACK:		for my $pack (keys %todo) {
			my $p = $package{$pack};

			if (! $p->{v_installed}) {
				$needed{$pack} = 0;
				delete $todo{$pack};
				next;
			} elsif ($p->{picked}
				|| ($p->{tag_category} // '')
					=~ /(?:^|\s)Base(?:\s|$)/) {
				$needed{$pack}++;
				delete $todo{$pack};
				next;
			}

			# if at least one rdep is needed, then this pack
			# is also needed
			for my $rdep (@{$p->{rdeps}}) {
				if (! exists $todo{$rdep} && $needed{$rdep}) {
					$needed{$pack}++;
					delete $todo{$pack};
					next PACK;
				}
			}

			# only if all rdeps are not needed is this pack
			# not needed
			for my $rdep (@{$p->{rdeps}}) {
				next PACK
					if exists $todo{$rdep};
			}

			push @remove, $pack;
			$needed{$pack} = 0;
			delete $todo{$pack};
		}

		if (keys %todo == $before_count) {
			# looks like a possible dependency loop, mark the first
			# package as not needed, and try again
			my ($pack) = keys %todo;
			my $p = $package{$pack};
			push @remove, $pack;
			delete $todo{$pack};
		}
	}

	return \@remove;
}

sub fix {
	my (%add, %dep);
	for my $p (grep { $_->{v_installed} } values %package) {
		my $pack = $p->{name};

		my $lst_name = $root."/etc/setup/$pack.lst.gz";
		unless (-e $lst_name || $pack eq 'cygapt') {
			print STDERR "W: Cannot read file list for package ",
				"$pack; $lst_name: $!\n";
			$add{$pack}++;
		}

		my $v = $p->{versions}{$p->{v_installed}};
		for my $dep (@{$v->{deps}}) {
			next
				if exists $package{$dep}
				&& $package{$dep}{v_installed};
			print STDERR "W: Dependency $dep of package $pack is ",
				"not installed\n";

			my $depp = $package{$dep};
			select_package_versions($depp, 'now', undef);

			# make minimal changes, only pull in missing deps
			my $depv = $depp->{versions}{$depp->{v_target}};
			$add{$dep}++;
			for my $depdep (@{$depv->{deps}}) {
				my $depdepp = $package{$depdep};
				next
					if $depdepp->{v_installed};
				select_package_versions($depdepp, undef, undef);
				$dep{$depdep}++;
			}
		}
	}

	map delete $dep{$_}, keys %add;
	my $changes = keys %dep ? upgradable(keys %dep) : { };
	$changes->{ask} = 1;
	push @{$changes->{installs}}, keys %add;

	return $changes;
}

sub build_tree {
	my ($quiet) = @_;

	print "Building dependency tree\n"
		unless $quiet;

	for my $p (values %package) {
		_build_tree($p, 0);
	}

	# dedup rdeps
	for my $p (values %package) {
		my %rd = map { $_ => 1 } @{$p->{rdeps}};
		$p->{rdeps} = [ keys %rd ];
	}
}

sub _build_tree {
	my ($p, $n) = @_;

	return
		if exists $p->{dep_depth};
	# loop detection
	print "_build_tree $p->{name} [$n]\n"
		if $debug > 2;
	if ($p->{loop}) {
		print "looping on $p->{name}; depth 0\n"
			if $debug > 2;
		$p->{dep_depth} = 0;
		return;
	}
	$p->{loop} = 1;

	my $max_dep_depth = 0;
	for my $v (values %{$p->{versions}}) {
		my @dep;
		if (exists $v->{tag_depends2}) {
			# ignore versioned depends
 			(my $dep = $v->{tag_depends2}) =~ s/\s*\([^)]+\)//g;
			@dep = split /,\s*/, $v->{tag_depends2};
		} elsif (exists $p->{tag_requires}) {
			@dep = split /\s+/, $p->{tag_requires};
		}
		$v->{deps} = \@dep;

		print "\t$p->{name} $v->{version}: @dep\n"
			if $debug > 2;

		for my $d (@dep) {
			unless (exists $package{$d}) {
				print "unsatisfied dep from ",
					"$p->{name} to $d\n"
					if $debug;
				$max_dep_depth = -10_000;
				last;
			}
			my $rd = $package{$d};
			push @{$rd->{rdeps}}, $p->{name};
			_build_tree($rd, $n+1);
			$max_dep_depth = $rd->{dep_depth} + 1
				unless $max_dep_depth
					> $rd->{dep_depth} + 1;
		}
	}

	$p->{dep_depth} = $max_dep_depth;
	delete $p->{loop};
	print "_build_tree $p->{name} [$n]: $max_dep_depth\n"
		if $debug > 2;
}

sub upgradable {
	my $opt;
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';
	my $quiet = $opt->{quiet};
	$| = 1;
	print "Calculating upgrade... "
		unless $quiet;

	my @arg_found;
	my ($re, $t_rels, $t_vers) = argv2pack_re(@_);

	my (%install, @reinstall, @upgrade);
	for my $pack (keys %package) {
		my $p = $package{$pack};

		$a = undef;
		if ($re) {
			next
				if $pack !~ $re;
			$arg_found[$a]++;
			if ($pack ne $_[$a]) {
				unless ($quiet) {
					print "Done\n";
					$quiet = 1;
				}
				if ($opt->{install} || $p->{v_installed}) {
					print "Note, selecting '$pack' for ",
						"glob '$_[$a]'\n";
				} else {
					# ignore uninstalled package during
					# upgrade
					next;
				}
			}
		} elsif (! $p->{v_installed}) {
			next;
		}

		select_package_versions($p,
			defined $a ? $t_rels->[$a] : $target_release,
			defined $a ? $t_vers->[$a] : undef);

		if (! $p->{v_target}) {
			print STDERR "W: no installable version for $pack\n"
				if $re;
			next;
		} elsif (! $p->{v_installed}) {
			$install{$pack}++;
			next;
		} elsif ($p->{v_target} eq $p->{v_installed}) {
			if ($reinstall) {
				push @reinstall, $pack;
			} elsif ($re) {
				unless ($quiet) {
					print "Done\n";
					$quiet = 1;
				}
				if (! $p->{picked}) {
					$p->{picked} = 1;
					print "$pack set to manually ",
						"installed.\n";
					lock_installed();
					write_installed();
				}
				print "$pack is already the newest ",
					"version ($p->{v_installed})\n";
			}
			next;
		}

		push @upgrade, $pack;
	}

	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		if ($_[$i] =~ m{\.tar\.(?:gz|bzip2|xz)}i && -f $_[$i]) {
			print "Done\n"
				unless $quiet;
			$quiet = 1;

			my $file = $_[$i];
			my ($pack, $vers) = pack_vers_from_file($_[$i]);
			if ($pack && $vers) {
				print "W: selecting package \"$pack\" ",
					"version \"$vers\" from file ",
					"$_[$i]\n";
				_available_store($pack, 'file', {
					tag_version => $vers,
					local_file => $_[$i],
				});
				$package{$pack}{v_target} = $vers;
				if (! $package{$pack}{v_installed}) {
					$install{$pack}++;
				} elsif ($package{$pack}{v_installed}
					ne $vers) {
					push @upgrade, $pack;
				} else {
					push @reinstall, $pack;
				}
				next;
			}
		}
		unless ($quiet) {
			print "Done\n";
			$quiet = 1;
		}
		print STDERR "E: Unable to locate package $_[$i]\n";
		$rc = 0;
	}
	return (undef)
		unless $rc;


	my $changes;
	my %opt_i = ( fullrecurse => ~0, print => 0 );

	# should only search for depends of newly installed, not reinstall
	map(depends(\%opt_i, $_), keys %install);
	my %opt_u = ( %opt_i );
	# but upgrades for reinstall depends are included
	map(depends(\%opt_u, $_), @upgrade, @reinstall);

	my $in = $opt_i{uninstalled_level};
	$changes->{installs} = [ @reinstall, sort { $in->{$b} <=> $in->{$a} }
		grep exists $in->{$_}, keys %install ];
	$changes->{install_deps} = [ sort { $in->{$b} <=> $in->{$a} }
		grep ! exists $install{$_}, keys %$in ];

	my $up = $opt_u{upgradable_level};
	$changes->{upgrades} = [ sort { $up->{$b} <=> $up->{$a} }
		grep ! exists $install{$_}, keys %$up ];

	my $un = $opt_i{uninstalled_level};
	$changes->{upgrade_deps} = [ sort { $un->{$b} <=> $un->{$a} }
		grep ! exists $in->{$_}, keys %$un ];

	print "Done\n"
		unless $quiet;

	return $changes;
}

sub list_depends {
	my $opt = { };
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';
	$opt->{fullrecurse} //= 1;
	$opt->{recurse} //= ~0;
	$opt->{print} //= 1;
	$opt->{uninstalled_level} //= { };

	my @arg_found;
	my ($re, $t_rels, $t_vers) = argv2pack_re(@_);

	for my $pack (sort keys %package) {
		$a = undef;
		next
			if $re && $pack !~ $re;
		$arg_found[$a]++;
		print "Note, selecting '$pack' for glob '$_[$a]'\n"
			if $pack ne $_[$a];
		my $p = $package{$pack};

		$opt->{t_rel} = $t_rels->[$a];
		$opt->{t_ver} = $t_vers->[$a];
		select_package_versions($p, $opt->{t_rel}, $opt->{t_ver});

		if ($opt->{print} || ! $p->{v_installed} || ! $p->{v_target}) {
		} else {
			if ($p->{v_installed} ne $p->{v_target}) {
			} else {
				print "$pack is already the newest version ",
					"($p->{v_installed})\n";
			}

			if (! $p->{picked}) {
				$p->{picked} = 1;
				print "$pack set to manually ",
					"installed.\n";
				lock_installed();
				write_installed();
			}
		}

		$opt->{depends} = { }
			if $opt->{print};
		depends($opt, $pack);
		$opt->{install}{$pack} = 1;
	}

	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		print STDERR "E: Unable to locate package $_[$i]\n";
		$rc = 0;
	}
	return $rc;
}

sub depends {
	my ($opt, $pack) = @_;
	# defaults to collecting all uninstalled
	$opt->{level} //= 0;
	$opt->{recurse} //= ~0;
	$opt->{fullrecurse} //= 0;
	$opt->{uninstalled_level} //= { };
	$opt->{upgradable_level} //= { };
	my $rc = 1;

	return $rc
		if $opt->{depends}{$pack};
	unless (exists $package{$pack}) {
		print STDERR "E: no installable version for $pack\n";
		return 0;
	}
	my $p = $package{$pack};
	$opt->{depends}{$pack}++;

	select_package_versions($p, $opt->{t_rel}, $opt->{t_ver});

	if ($opt->{print}) {
		my @t;
		push @t, 'installed'
			if $p->{v_installed};
		if ($p->{v_installed} && $p->{v_target}
			&& $p->{v_target} ne $p->{v_installed}) {
			$opt->{upgradable_level}{$pack} = 999 - $p->{dep_depth};
			push @t, 'upgradable';
		}

		print '  ' x $opt->{level}, $pack,
			@t ? " [".join(",", @t)."]" : "",
			"\n"
	} elsif ($p->{v_installed} && $p->{v_target}
		&& $p->{v_target} ne $p->{v_installed}) {
		$opt->{upgradable_level}{$pack} = 999 - $p->{dep_depth};
	}

	# recurse until we find an installed version
	# or if fullrecurse
	return $rc
		if ($opt->{recurse} <= 0
			|| $p->{v_installed}
				&& $p->{v_installed} eq $p->{v_target})
		&& $opt->{fullrecurse} <= 0;
	$opt->{uninstalled_level}{$pack} = 5000 - $p->{dep_depth}
		unless $p->{v_installed} && ! $reinstall;
	unless ($p->{v_target}) {
		print STDERR "E: no installable version for $pack\n";
		return 0;
	}

	my $vers = $opt->{installed_version} && $p->{v_installed}
		? $p->{v_installed} : $p->{v_target};
	my $v = $p->{versions}{$vers};
	my %opt2 = (
		%$opt,
		level => $opt->{level}+1,
		recurse => $opt->{recurse}-1,
		fullrecurse => $opt->{fullrecurse}-1,
		t_ver => undef
	);
	for my $d (@{$v->{deps}}) {
		$rc = 0
			unless depends(\%opt2, $d);
	}

	return $rc;
}

sub list_rdepends {
	my $opt = { };
	$opt = shift @_
		if @_ && ref $_[0] eq 'HASH';
	$opt->{print} //= 1;
	$opt->{level} //= 0;
	$opt->{installed_level} //= { };

	my (@arg_found, @not_removed);
	my ($re) = argv2pack_re(@_);
	for my $pack (sort keys %package) {
		next
			unless $pack =~ m{$re};
		$arg_found[$a]++;
		print "Note, selecting '$pack' for glob '$_[$a]'\n"
			if $pack ne $_[$a];
		next
			unless ! exists $opt->{rdepends}{$pack};
			#&& $package{$pack}{v_installed};

		# complain about removal of not installed packages,
		# unless they are selected by a glob
		push @not_removed, $pack
			unless $package{$pack}{v_installed}
			|| $pack ne $_[$a];

		$opt->{installed_level}{$pack} = $opt->{level}
			if $package{$pack}{v_installed};
		rdepends({ %$opt, level => $opt->{level} }, $pack);
	}

	my $rc = 1;
	for my $i (0..$#_) {
		if (! $arg_found[$i]) {
			$rc = 0;
			print STDERR "E: Unable to locate package $_[$i]\n";
		}
	}
	for my $pack (@not_removed) {
		print STDERR "Package '$pack' is not installed, ",
			"so not removed\n";
		$rc = 0;
	}
	return $rc;
}

sub rdepends {
	my ($opt, $dep) = @_;
	$opt->{level} //= 0;

	if ($opt->{print}) {
		my $p = $package{$dep};
		my @t;
		push @t, 'installed'
			if $p->{v_installed};
		push @t, 'upgradable'
			if $p->{v_installed} && $p->{v_target}
			&& $p->{v_target} ne $p->{v_installed};
		print '  ' x $opt->{level}, "$dep",
			@t ? " [".join(",", @t)."]" : "", "\n";
	}

	for my $pack (@{$package{$dep}{rdeps}}) {
		next
			if exists $opt->{rdepends}{$pack}
			|| ! $package{$pack}{v_installed};
		my $p = $package{$pack};
		$opt->{rdepends}{$pack} = 1;
		$opt->{installed_level}{$pack} = $opt->{level};

		rdepends({ %$opt, level => $opt->{level}+1 }, $pack);
	}
}

sub search {
	my $opt = shift @_;

	my @re = map glob2re($_), @_;
	my $re;
	if ($opt->{combine} eq '||') {
		$re = join("|", map "(?:$_)", @re);
		$re = qr{$re}ims;
	} else {
		$re = join("", map "(?=.*$_)", @re);
		$re = qr{^$re}ims;
	}
	print "Match: $re\n"
		if $debug;

	for my $pack (sort keys %package) {
		my $p = $package{$pack};

		my $info = ($p->{tag_ldesc} ? "\n$p->{tag_ldesc}" : "");
		# indent ldesc
		$info =~ s{\n}{\n }gms;
		$info = ($p->{tag_sdesc} ? "$p->{tag_sdesc}" : "").$info;

		next
			unless $info =~ $re;

		if ($color) {
			# colorize matches
			for my $w (@re) {
				$info =~ s{($w)}
					{color('green').$1.color('reset')}geims;
			}
		}

		print "\n$pack: $info\n";
	}
}

sub find {
	state %file2pack;

	# if not a glob, and we already parsed all lst, keep it simple
	return $file2pack{$_[0]}
		if keys %file2pack && @_ == 1 && $_[0] !~ /[*?{}]/;

	my @arg_found;
	my $re = argv2re(map {
		# drop first slash
		my $a = $_;
		$a = "*$a"
			unless $a =~ s{^/+}{};
		$a;
	} @_);

	if (keys %file2pack) {
		for my $file (keys %file2pack) {
			return $file2pack{$file}
				if $file =~ $re;
		}
	}

	my @found;
	for my $pack (sort keys %package) {
		my $p = $package{$pack};
		next
			unless $p->{v_installed};

		my $lst_fh;
		my $lst_name = "$root/etc/setup/$pack.lst.gz";
		if ($lst_fh = gzopen($lst_name, 'rb')) {
			my $line;
			my $cnt = 0;
			while($lst_fh->gzreadline($line)) {
				$file2pack{$line} = $pack;

				if ($line =~ $re) {
					if (wantarray) {
						push @found, $pack;
						last;
					}

					$arg_found[$a]++;
					print "$pack:\n"
						unless $cnt;
					print "\t/$line";
					$cnt++;
				}
			}
			$lst_fh->gzclose;
		} elsif ($pack ne 'cygapt') {
			print STDERR "W: Cannot read $lst_name: $!\n";
		}
	}

	return @found
		if wantarray;
	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		print STDERR "E: Found no package containing files ",
			"like $_[$i]\n";
		@found = ();
	}
	return @found;
}

sub files {
	my @arg_found;
	my ($re, $t_rels, $t_vers) = argv2pack_re({ installed => 1 }, @_);

	for my $pack (sort keys %package) {
		$a = undef;
		next
			if $re && $pack !~ $re;
		$arg_found[$a]++;

		my $p = $package{$pack};
		unless ($p->{v_installed}) {
			print "$pack is not yet installed\n";
			next;
		}

		print "$pack:\n";
		my $lst_fh;
		my $lst_name = "$root/etc/setup/$pack.lst.gz";
		if ($lst_fh = gzopen($lst_name, 'rb')) {
			my $line;
			while($lst_fh->gzreadline($line)) {
				print "\t$line";
			}
			$lst_fh->gzclose;
		} else {
			print STDERR "W: Cannot read $lst_name: $!\n";
		}
	}

	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		print STDERR "E: Unable to locate installed package $_[$i]\n";
		$rc = 0;
	}
	return $rc;
}

sub mark {
	my $picked = shift;
	my @arg_found;
	my ($re, $t_rels, $t_vers) = argv2pack_re({ installed => 1 }, @_);

	lock_installed();
	for my $pack (sort keys %package) {
		$a = undef;
		next
			if $re && $pack !~ $re;
		$arg_found[$a]++;

		my $p = $package{$pack};
		unless ($p->{v_installed}) {
			print "$pack is not yet installed\n";
			next;
		}

		if ($p->{picked} != $picked) {
			$p->{picked} = $picked;
			print "$pack set to ",
				$picked ? "manually" : "automtically",
				" installed.\n";
			write_installed();
		} else {
			print "$pack already set to ",
				$picked ? "manually" : "automtically",
				" installed.\n";
		}
	}

	my $rc = 1;
	for my $i (0..$#_) {
		next
			if $arg_found[$i];
		print STDERR "E: Unable to locate installed package $_[$i]\n";
		$rc = 0;
	}
	return $rc;
}

sub my_deps {
	print STDERR "W: my-deps may give wrong results with --root\n"
		if $root;
	get_available();
	build_tree();
	get_installed();

	my @files = (values %INC, keys %{ my_dlls() });

	if ($debug) {
		$| = 1;
		print "Files:\n";
		print_array(@files);
		find(@files);
	}

	my %pack = map { $_ => 1 } find(@files);
	if ($debug || $verbose) {
		print "full cygapt dependencies:\n";
		print_array(sort keys %pack);
	}

	# simplify
	for my $pack (keys %pack) {
		my $p = $package{$pack};
		for my $dep (@{$p->{versions}{$p->{v_installed}}{deps}}) {
			delete $pack{$dep};
		}
	}
	print "cygapt depends on:\n";
	print_array(sort keys %pack);
}

sub my_dlls {
	state $dlls;
	return $dlls
		if $dlls;

	map $dlls->{$_} = $_, @DynaLoader::dl_shared_objects;

	my $ldd = `ldd /usr/bin/perl`;
	map $dlls->{$_} = $_, ($ldd =~ m{=> (/.*?\.dll)}gmis);
	$dlls->{'/usr/bin/perl.exe'} = '/usr/bin/perl.exe';

	return $dlls;
}

sub get_setup {
	my $fh;

	unless (open $fh, '<', $root.SETUP) {
		print STDERR "E: Cannot open ", $root.SETUP, ": $!\n";
		exit 10;
	}

	my $key;
	while(<$fh>) {
		if ($key && /^\s+(\S.*)\r?\n/) {
			push @{$setup{$key}}, $1;
		} elsif (/^(\S+)\s*$/) {
			($key = $1) =~ s/-/_/g;
		} else {
			print STDERR "W: Did not recognize ", $root.SETUP,
				" format", $key ? " section $key" : "",
				": $_";
		}

	}

	close ($fh);

	unless (exists $setup{last_mirror}) {
		print STDERR "E: Did not find last-mirror in ", SETUP, "\n";
		exit 10;
	}

	($setup{arch} = (uname)[4]) =~ s/^i6/x/;
}

sub term_width {
	state $term_width //= (GetTerminalSize())[0];
	return $term_width;
}

sub print_array {
	local $| = 0;
	my $width = term_width();

	print " ";
	my $w = 1;
	for my $a (@_) {
		if ($w + length($a) > $width-3) {
			print "\n  $a";
			$w = 2 + length($a);
		} else {
			print " $a";
			$w += 1 + length($a);
		}
	}
	print "\n";
}

sub get_installed {
	my ($quiet) = @_;
	unless ($quiet) {
		$| = 1;
		print "Reading state information... ";
	}
	my $fh;

	unless (open $fh, '<', $root.INSTALLED) {
		print STDERR "\nE: Cannot open ", $root.INSTALLED, ": $!\n";
		exit 10;
	}
	unless (flock($fh, LOCK_SH | LOCK_NB)) {
		print STDERR "\nE: Could not get lock ", $root.INSTALLED,
			" - open ($!)\n";
		exit 10;
	}

	my $version;
	while(<$fh>) {
		if (/^INSTALLED.DB\s+(\d+)/) {
			$version = $1;
			next;
		}

		unless (/^(\S+)\s+(\1-(\S+)\.tar\.\S+)\s+(\d+)$/) {
			print STDERR "W: Did not recognize ", $root.INSTALLED,
				" format: $_";
			next;
		}
		my ($pack, $file, $version, $picked) = ($1, $2, $3, $4);

		my $p;
		if (exists $package{$pack}) {
			$p = $package{$pack};
		} else {
			$p = $package{$pack} = {
				name => $pack,
				versions => { },
			};
		}
		$p->{v_installed} = $version;
		$p->{picked} = $picked;

		my $v;
		if (exists $p->{versions}{$version}) {
			$v = $p->{versions}{$version};
		} else {
			$v = $p->{versions}{$version} = {
				tag_version => $version,
				va => v2va($version),
			};
		}

		$v->{installed} = 1;
		$v->{tag_version} = $version;
		$v->{file} = $file;
		push @{$v->{releases}}, 'now';
	}

	close($fh);

	print "Done\n"
		unless $quiet;
}

my $installed_fh;
sub lock_installed {
	return
		if $installed_fh;

	unless (keys %package) {
		print STDERR "E: Refusing to write empty installed.db!\n";
		exit 10;
	}

	rename($root.INSTALLED, $root.INSTALLED.".orig");
	unless (open $installed_fh, '+>', $root.INSTALLED) {
		print STDERR "E: Cannot open ", $root.INSTALLED, ": $!\n";
		exit 10;
	}
	unless (flock($installed_fh, LOCK_EX)) {
		print STDERR "E: Could not get lock ", $root.INSTALLED,
			" - open ($!)\n";
		exit 10;
	}

	write_installed();
}

sub write_installed {
	die "write_installed() called without lock held"
		unless $installed_fh;

	# protect against incomplete installed.db updates
	my $break;
	local $SIG{INT} = sub { $break = 1 };
	$SIG{TERM} = $SIG{INT};
	$SIG{QUIT} = $SIG{INT};

	seek($installed_fh, 0, SEEK_SET);
	print $installed_fh "INSTALLED.DB 3\n";
	for my $pack (sort keys %package) {
		my $p = $package{$pack};
		next
			unless $p->{v_installed};

		my $file;
		if (exists $p->{versions}{$p->{v_installed}}) {
			my $v = $p->{versions}{$p->{v_installed}};
			if (exists $v->{file}) {
				$file = $v->{file};
			} elsif (exists $v->{tag_install}) {
				$file = $v->{tag_install};
				$file =~ s{\s+.*$}{};
				$file =~ s{^.*/}{};
			}
		}
		$file //= "$pack-$p->{v_installed}.tar.bz2";

		print $installed_fh "$pack $file $p->{picked}\n";
	}

	truncate($installed_fh, tell($installed_fh));

	if ($debug > 1) {
		print "INSTALLED DIFF:\n";
		system('diff', '-u', $root.INSTALLED.".orig", $root.INSTALLED);
		print "END INSTALLED DIFF:\n";
	}

	if ($break) {
		print STDERR "E: Killed\n";
		exit 10;
	}
}

sub unlock_installed {
	write_installed();
	flock($installed_fh, LOCK_UN | LOCK_NB);
	close($installed_fh);
	$installed_fh = undef;
}

sub get_available {
	my ($quiet) = @_;

	unless ($quiet) {
		$| = 1;
		print "Reading package lists... ";
	}

	my $i = 0;
	for my $mirror (@{$setup{last_mirror}}) {
		printf "\rReading package lists... %d%%",
			$i * 100 / @{$setup{last_mirror}}
			unless $quiet;
		get_available_mirror($mirror, $quiet);
		$i++;
	}

	print "\rReading package lists... 99%"
		unless $quiet;
	for my $p (values %package) {
		for my $v (values %{$p->{versions}}) {
			# uniq releases
			$v->{releases} = [ sort keys
				%{ { map { $_ => 1 } @{$v->{releases}} } } ];
		}
	}

	print "\rReading package lists... Done\n"
		unless $quiet;
}

sub get_available_mirror {
	my ($mirror, $quiet) = @_;

	my $fh;
	my $setup_name = $root.join("/", 
		CACHE, uri_escape($mirror), $setup{arch}, "setup.ini");

	unless (open $fh, '<', $setup_name) {
		print STDERR "E: Cannot open ", $setup_name, ": $!\n";
		exit 10;
	}

	my ($key, $val);
	while(<$fh>) {
		next
			if /^\s*#/;

		last
			if /^\s*$/;

	}

	my ($pack, $rel, $vals);
	while(<$fh>) {
		chomp;

		if (/^\@\s+(\S+)/) {
			$pack = $1;
			$rel = 'curr';
			$vals->{base} = $mirror;
			next;
		} elsif (/^\[(\S+)\]/) {
			# store only if there was something
			_available_store($pack, $rel, $vals)
				if exists $vals->{tag_version};
			$rel = $1;
			$vals = { base => $mirror };
			next;
		} elsif ($key && defined $val) {
			$val .= "\n$_";
		} elsif (/^\s*$/) {
			# store
			_available_store($pack, $rel, $vals);
			$pack = undef;
			$vals = undef;
			next;
		} elsif (/^(\S+):\s+(.*)$/) {
			($key, $val) = ($1, $2);
		} else {
			print STDERR "W: Did not recognize $setup_name",
				" line $. format: $_\n";
			next;
		}

		# all quotes need to be closed, they are in pairs
		my $q = () = $val =~ /"/g;
		next
			if $q & 1;

		$vals->{"tag_$key"} = $val;
		$key = undef;
	}

	close($fh);
}

sub _available_store {
	my ($pack, $rel, $vals) = @_;

	unless (exists $vals->{tag_version}) { # && exists $vals->{sdesc}) {
		print STDERR "W: package $pack doesn't have ",
			"'version' tag\n";
		print Dumper($vals)
			if $debug;
		return;
	}
	my $version = $vals->{tag_version};

	my $p;
	if (exists $package{$pack}) {
		$p = $package{$pack};
	} else {
		$p = $package{$pack} = {
			name => $pack,
			versions => { },
		};
	}
	
	for my $k (qw(tag_sdesc tag_ldesc tag_category tag_message
		tag_requires)) {
		next
			unless exists $vals->{$k};
		my $t = $vals->{$k};
		$t =~ s/^"(.*)"$/$1/ms;
		$p->{$k} = $t;
		delete $vals->{$k};
	}

	my $v;
	if (exists $p->{versions}{$version}) {
		$v = $p->{versions}{$version};
	} else {
		$v = $p->{versions}{$version} = {
			version => $version,
			va => v2va($version),
		};
	}

	push @{$v->{releases}}, $rel;
	for my $k (keys %$vals) {
		$v->{$k} //= $vals->{$k};
	}
}

sub select_package_versions {
	my ($p, $t_rel, $t_ver) = @_;

	return
		if exists $p->{v_target};

	print "find $p->{name} for rel ", $t_rel // '<u>', 
		" ver ", $t_ver // '<u>', "\n"
		if $debug;

	my @v = sort { vacmp($b->{va}, $a->{va}) } values %{$p->{versions}};
	$p->{versions_sorted} = \@v;
	for my $i (0..$#v) {
		$v[$i]{version_idx} = $i;
	}

	$p->{v_latest} = $v[0]{tag_version};

	my $target = $v[-1]{tag_version};
	my $i = 0;
	while($i < @v && $v[$i]{releases}[0] eq 'test') {
		$i++;
	}
	$target = $v[$i]{tag_version}
		unless $i > $#v || $v[$i]{releases}[0] eq 'test';
	$p->{v_target} = $target;

	$target = undef;
	if ($t_ver) {
		# newest version that matches $t_ver
		$target = (grep m{$t_ver},
			map($_->{tag_version}, @v))[0];
	} elsif ($t_rel) {
		# newest version that has a release that matches $t_rel
		$target = (map $_->{tag_version},
			grep {
				grep $_ =~ m{$t_rel}, @{$_->{releases}}
			} @v)[0];
	}

	# only pick new target if it is newer, or we can downgrade (or no
	# prior target) and we have a download
	$p->{v_target} = $target
		if $target && ($downgrades
			|| ! $p->{v_target}
			|| $p->{versions}{$target}{version_idx} <
				$p->{versions}{$p->{v_target}}{version_idx})
		&& $p->{versions}{$target}{tag_install};
}

sub pack_vers_from_file {
	my ($file) = @_;
	$file =~ s{^.*/}{};
	$file =~ s{\.tar\.(?:gz|bzip2|xz)$}{}i;
	(my $pre = $file) =~ s/-.*$//;

	# longest matched package name
	my $len = -1;
	for my $pack (grep /^$pre/, keys %package) {
		next
			unless substr($file, 0, length($pack)) eq $pack
			&& length($pack) > $len;
		$len = length($pack);
	}

	if ($len > 0) {
		return (substr($file, 0, $len), substr($file, $len+1));
	} else {
		return (undef, undef);
	}
}

my ($http_total_size, $http_total_count, $http_size, $http_start, $http_end,
	$http_speed);

sub http_start {
	($http_total_size, $http_total_count) = @_;
}

sub http_get {
	my ($url, $file, $total_size, $hash, $sub) = @_;
	$url =~ s{(?<=[^:])//+}{/}g;
	print "get $url\n"
		if $debug;
	my $name = $url;
	if ($url =~ /setup.bz2$/) {
		$name =~ s{^[htpsf]+:?/+}{};
		$name =~ s{/.*}{};
	} else {
		$name =~ s{^.*/}{};
	}

	my $width = term_width();
	$name = substr($name, 0, $width - 33 - 3)."..."
		if length($name) > $width - 33;

	my ($hmac, $match);
	if (! $hash) {
	} elsif (length($hash) == 128) {
		$hmac = Digest::SHA->new(512);
		$match = sub { $hmac->hexdigest eq $hash };
	} elsif (length($hash) == 86) {
		$hmac = Digest::md5->new();
		$match = sub { $hmac->b64digest eq $hash };
	} else {
		print STDERR "W: $name has unknown hash format $hash\n";
	}

	state $forecast;
	state $ua = get_user_agent();
	state $idx = 0;
	$idx++;

	my $start = time;
	$http_size //= 0;
	$http_start = $start
		unless $http_start && $http_start < $start;
	_http_show_progress("[$idx $name Waiting for headers]", $start,
		$http_size);

	my $fh;
	(my $dir = $file) =~ s{[^/]+$}{};
	mkdir_p($dir);
	unless (open $fh, '>', "$file.new") {
		print STDERR "E: Could not write $file.new: $!\n";
		exit 10;
	}

	my $req = HTTP::Request->new(GET => $url);
	
	if (-e $file) {
		my $t = (stat _)[9];
		$req->header('If-Modified-Since', time2str($t));
	}

	my $data;
	my $size = 0;
	my $res = $ua->request($req, sub {
		my ($data) = @_;
		$data = $sub->($data)
			if $sub;
		$hmac->add($data)
			if $hmac;
		print $fh $data;

		state $last = 0;
		my $res = $_[1];
		unless (defined $total_size) {
			$total_size = $res->header('Content-Length') // -1;

			if ($total_size <= 0) {
			} elsif (! $http_total_size) {
				# guess all are the same size
				$http_total_size = $total_size
					* $http_total_count;
				$forecast = 1;
			} elsif ($forecast && $idx == $http_total_count) {
				$http_total_size =
					$http_total_size
					* ($http_total_count-1)
					/ $http_total_count
					+ $total_size;
			}
		}
		$size += length($_[0]);

		my $now = time;
		return
			unless $now - $last > 0.2;
		$last = $now;

		# progress
		my $s;
		unless ($size || $total_size) {
			$s = 'Waiting for headers';
		} elsif ($total_size > 0) {
			$s = sprintf("%s/%s %d%%",
				size2t($size), size2t($total_size),
				100 * $size / $total_size);
		} else {
			$s = size2t($size);
		}
		my $pro = "[$idx $name $s]";

		# overall progress
		if ($http_total_size) {
			_http_show_progress($pro, $now, $http_size + $size);
		} elsif ($color) {
			print color('yellow'), $pro,
				color('reset'), "\e[K\r";
		} else {
			print "$pro\e[K\r";
		}
	});

	# flush
	$sub->(undef)
		if $sub;

	close($fh);
	my $end = time;
	$http_end = $end
		unless $http_end && $http_end > $end;

	my $rc = 0;
	if ($res->is_success) {
		if ($match && ! $match->()) {
			print "Err:$idx $url\e[K\r\n does not verify\n";
			unlink("$file.new");
			print STDERR "W: Failed to match hash $url\e[K\r\n";
		} else {
			if (my $t = $res->header('Last-Modified')) {
					$t = str2time($t);
					utime $t, $t, "$file.new";
			}
			rename("$file.new", $file);
			print "Get:$idx $url\e[K\r\n";
			$http_size += $total_size // $size;
			$rc = $total_size // $size;
		}
	} elsif ($res->code == 304) {
		# not modified
		print "Hit:$idx $url\e[K\r\n";
		unlink("$file.new");
		$size = -s $file;
		$rc = $size;
	} else {
		print "Err:$idx $url\e[K\r\n ", $res->message, "\n";
		unlink("$file.new");
		print STDERR "W: Failed to fetch $url ", $res->message,
			"\e[K\r\n";
	}

	# show overall progress
	_http_show_progress(undef, $end, $http_size)
		if $http_total_count && $idx < $http_total_count && $rc;

	return $rc;
}

sub _http_show_progress {
	my $width = term_width();
	my ($msg, $now, $s) = @_;
	state $last_msg;
	if ($msg) {
		$last_msg = $msg;
	} else {
		$msg = $last_msg;
	}
	$s ||= 0;

	if ($http_total_size) {
		$msg = sprintf("%d%% ", $s / $http_total_size * 100)
			.$msg
			if $http_total_count > 1;

		my $speed = $now == $http_start ? 0 : $s / ($now - $http_start);
		# smooth out calculated download speed
		$http_speed = $http_speed
			? $speed * 0.01 + $http_speed * 0.99
			: $speed;

		if ($now - $http_start > 5) {
			my $todo = ($http_total_size - $s)
				/ $http_speed;

			# overall progress
			use integer;
			my $pro = $todo > 60*60
				? sprintf("%dh %02dm %02ds",
					$todo / 60 / 60,
					($todo / 60) % 60, $todo % 60)
				: $todo > 60
				? sprintf("%dm %02ds",
					$todo / 60, $todo % 60)
				: sprintf("%ds", $todo);
			$pro = size2t($http_speed)."/s $pro ";

			if ($width) {
				my $len = length($msg) + length($pro);
				# right align it, if there is space
				$msg .= (' 'x($width - $len))
					.$pro
					if $width > $len;
			} else {
				$msg .= ' '.$pro;
			}
		}
	}

	if ($color) {
		print color('yellow'), $msg,
			color('reset'), "\e[K\r";
	} else {
		print "$msg\e[K\r";
	}
}

sub http_done {
	printf "\e[K";
	return
		unless $http_size;
	printf "Fetched %s in %ds (%s/s)\n",
		size2t($http_size), $http_end - $http_start,
		size2t($http_size / ($http_end - $http_start));
}

sub get_user_agent {
	my $ua = LWP::UserAgent->new(
		agent => "cygapt/".VERSION
	);
	$ua->proxy(['http', 'https', 'ftp']
		=> "http://".$setup{net_proxy_host}[0]
			.":".$setup{net_proxy_port}[0])
		if exists $setup{net_proxy_host}
		&& exists $setup{net_proxy_port};
	$ua->env_proxy;
	return $ua;
}

sub uri_escape {
	my ($d) = @_;
	$d =~ s{([:/])}{sprintf("%%%02x", ord($1))}ge;
	return $d;
}

sub v2va {
	# split into groups of non-digits and digits
	# first is a group of digits
	return [ defined $_[0] ? split(/(\d+)/, $_[0]) : ('') ]
}

sub vacmp {
	my ($a, $b) = @_;
	my $i = 0;

	while(1) {
		last
			unless $i < @$a && $i < @$b;
		my $cmp = $a->[$i] cmp $b->[$i];
		return $cmp
			if $cmp;
		$i++;

		last
			unless $i < @$a && $i < @$b;
		$cmp = $a->[$i] <=> $b->[$i];
		return $cmp
			if $cmp;
		$i++;
	}

	if (@$a == @$b) {
		return 0;
	} elsif ($i < @$a) {
		return +1;
	} else {
		return -1;
	}
}

sub argv2re {
	return undef
		unless @_;

	my @re;
	for (@_) {
		push @re, glob2re("^$_\$")."(?{ \$a = ".scalar(@re)." })";
	}

	my $re;
	use re 'eval';
	$re = join('|', @re);
	$re = qr/(?:$re)/;
	print STDERR "Match: $re\n"
		if $debug;

	return $re;
}

sub argv2pack_re {
	return (undef, [], [])
		unless @_;

	my $opt = @_ && ref $_[0] eq 'HASH' ? shift @_ : { };
	my (@re, @t_rel, @t_ver);
	for my $a (@_) {
		# don't clobber contents of original array
		local $_ = $a;
		if (! $opt->{installed}) {
		} elsif (m{[=/](\S+)}) {
			print STDERR "E: Can only match installed ",
				"version: $_\n";
			exit 10;
		}
		print STDERR "W: Only select target version or release: $_\n"
			if m{/} && m{=};

 		push @t_rel, s{/(\S+)$}{} ? glob2re("^$1\$") : $target_release;
		push @t_ver, s{=(\S+)$}{} ? glob2re("^$1\$") : undef;

		push @re, glob2re("^$_\$")."(?{ \$a = ".scalar(@re)." })";
	}

	my $re;
	use re 'eval';
	$re = join('|', @re);
	$re = qr/(?:$re)/;
	print STDERR "Match: $re\n"
		if $debug;

	return ($re, \@t_rel, \@t_ver);
}

sub glob2re {
	my ($re) = @_;

	$re =~ s{([.+])}{\\$1}g;
	$re =~ s{\*}{.*}g;
	$re =~ s{\?}{.}g;
	$re =~ s[{([^}]*)]["(?:".join("|", split(/,/, $1)).")"]ge;
	
	return qr{$re};
}

sub mkdir_p {
	my ($dir) = @_;
	return
		if -d $dir;
	(my $up = $dir) =~ s{/[^/]*$}{};
	mkdir_p($up);
	mkdir $dir;
}

sub size2t {
	my ($s) = @_;
	state $fmt = [
		[ "%d B", 1, ],
		[ "%.1f kB", 1024, ],
		[ "%d kB", 1024, ],
		[ "%.1f MB", 1024 * 1024, ],
		[ "%d MB", 1024 * 1024, ],
		[ "%.1f GB", 1024 * 1024 * 1024, ],
		[ "%d GB", 1024 * 1024 * 1024, ],
	];

	my $t;
	for my $i (0..$#$fmt) {
		my $t2 = sprintf($fmt->[$i][0], $s / $fmt->[$i][1]);
		($t = $t2), last
			unless length($t2) > 7;
	}
	$t //= sprintf($fmt->[-1][0], $s / $fmt->[-1][1]);

	# thousands separator
	$t =~ m{(\d+)};
	my $n = $1;
	my $n2 = reverse join(",", unpack("(A3)*", reverse $n));
	$t =~ s{$n}{$n2};

	return $t;
}

sub logger {
	state $log_fh;

	unless ($log_fh) {
		if (! -e $root.LOG) {
			open $log_fh, '>', $root.LOG;
		} elsif (-s _ > 100_000) {
			# rotate
			rename $root.LOG.".3", $root.LOG.".4"; 
			rename $root.LOG.".2", $root.LOG.".3"; 
			rename $root.LOG.".1", $root.LOG.".2"; 
			rename $root.LOG, $root.LOG.".1"; 
			open $log_fh, '>', $root.LOG;
		} else {
			open $log_fh, '+<', $root.LOG;
		}

		return
			unless $log_fh;
		seek $log_fh, 0, SEEK_END;
	}

	print $log_fh localtime.": ", @_, "\n";
}

sub usage {
	my $fh = @_ ? *STDERR : *STDOUT;

	print $fh @_, "\n"
		if @_ && $_[0];
	print $fh <<USAGE;
Usage: cygapt [options] command

cygapt is a commandline package manager for Cygwin, that tries to provide
a similar interface as APT on Debian.

Commands:
USAGE

	for my $cmd (@command) {
		next
			if ref $cmd || ! exists $command{$cmd}{help};
		my $t = $command{$cmd}{help};
		$t =~ s{Usage:[^\n]*\n\n}{}ms;
		$t =~ s{\n.*$}{}ms;
		print $fh "  $cmd",
			length($cmd) >= 14 ? "\t"
			: length($cmd) >= 6 ? "\t\t"
			: "\t\t\t",
			"$t\n";
	}
	print $fh "\n";
	general_options($fh);

	exit @_ ? 10 : 0;
}

sub usage_cmd {
	my ($cmd) = shift @_;
	my $fh = @_ ? *STDERR : *STDOUT;
	print $fh @_, "\n"
		if @_ && $_[0];

	print $fh "$command{$cmd}{help}\n";
	general_options($fh);

	exit @_ ? 10 : 0;
}

sub general_options {
	my ($fh) = @_;
	print $fh <<OPTIONS;
General options:
  -s, -n, --dry-run	make no changes
  -h, --help		this help, or help about a command
  -root=ROOT		root directory of installation to act upon
  -D, --debug
OPTIONS
}
